{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"themes/indigo/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/style.less","path":"css/style.less","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/brand.jpg","path":"img/brand.jpg","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/cc.png","path":"img/cc.png","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/img-err.png","path":"img/img-err.png","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/img-loading.png","path":"img/img-loading.png","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/wechat.png","path":"img/wechat.png","modified":0,"renderable":1},{"_id":"themes/indigo/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/indigo/source/js/main.min.js","path":"js/main.min.js","modified":0,"renderable":1},{"_id":"themes/indigo/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/indigo/source/js/search.min.js","path":"js/search.min.js","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.eot","path":"css/fonts/roboto/Roboto-Bold.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff","path":"css/fonts/roboto/Roboto-Bold.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff2","path":"css/fonts/roboto/Roboto-Bold.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.eot","path":"css/fonts/roboto/Roboto-Light.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff2","path":"css/fonts/roboto/Roboto-Light.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.eot","path":"css/fonts/roboto/Roboto-Medium.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff2","path":"css/fonts/roboto/Roboto-Medium.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.eot","path":"css/fonts/roboto/Roboto-Regular.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff","path":"css/fonts/roboto/Roboto-Regular.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff2","path":"css/fonts/roboto/Roboto-Regular.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.eot","path":"css/fonts/roboto/Roboto-Thin.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff","path":"css/fonts/roboto/Roboto-Thin.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff2","path":"css/fonts/roboto/Roboto-Thin.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff","path":"css/fonts/fontawesome/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff2","path":"css/fonts/fontawesome/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff","path":"css/fonts/roboto/Roboto-Light.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff","path":"css/fonts/roboto/Roboto-Medium.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.ttf","path":"css/fonts/roboto/Roboto-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.ttf","path":"css/fonts/roboto/Roboto-Thin.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/FontAwesome.otf","path":"css/fonts/fontawesome/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.eot","path":"css/fonts/fontawesome/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.ttf","path":"css/fonts/fontawesome/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.ttf","path":"css/fonts/roboto/Roboto-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.ttf","path":"css/fonts/roboto/Roboto-Light.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.ttf","path":"css/fonts/roboto/Roboto-Medium.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.svg","path":"css/fonts/fontawesome/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/404.html","hash":"7d362e09fa93438b16beb7d12a5658041d2058b7","modified":1591621094992},{"_id":"themes/indigo/.editorconfig","hash":"67a03b88eadd7810f2e01866e73814074ecd3b87","modified":1591526964774},{"_id":"themes/indigo/LICENSE","hash":"9dd0f70bc72c9d575447655526aded395bb93754","modified":1591526964789},{"_id":"themes/indigo/README.md","hash":"cfc7d09fc2ce26003954d647e3bbf98f71574eb7","modified":1591526964789},{"_id":"themes/indigo/_config.yml","hash":"62049edcd56f0c4495f5cea3a106c5a301dbb68c","modified":1592124561819},{"_id":"themes/indigo/package.json","hash":"3ad9b9ccb1ddaad3136f179a7ebff7d7b1c193f7","modified":1591526964899},{"_id":"source/categories/index.md","hash":"dd907aab0e2fd3ae3cb3bacdccab2ac2fc0b6af4","modified":1591557140662},{"_id":"source/_posts/GitHub Pages+Hexo+Travis CI-自动化构建的静态博客.md","hash":"4d6951f50854ad0b9630983a54fd60359f04e338","modified":1592124561817},{"_id":"source/_posts/HashMap常用操作.md","hash":"459271f09302e2e8e7cd2cc64340260a8c52c9b3","modified":1593951124257},{"_id":"source/_posts/Java多线程和锁.md","hash":"b60035890eba55a064bf220c5cd1c5d474c274a4","modified":1593951124289},{"_id":"source/_posts/Hive-DDL-ROW-FORMAT.md","hash":"92a74a2d1e4a28e05fbe6c45d30401d57e7a926d","modified":1593951124292},{"_id":"source/_posts/My-First-Post-Test.md","hash":"5a056e92be79bdce864b90ae76044ea81962696e","modified":1591710288634},{"_id":"source/_posts/PAI算法组件详解-PLDA.md","hash":"b159765d68d6c1829b284d880ed2147cd2de004f","modified":1593951124316},{"_id":"source/_posts/amount-of-information.md","hash":"7c7ad79045333c5fe43119548ebfbff67d943662","modified":1593951124311},{"_id":"source/_posts/hello-world.md","hash":"d1f245f82acce5f302170602321d858e41d51c9f","modified":1593951124295},{"_id":"source/_posts/java-constant.md","hash":"bb42d6184bb73c7a4421d1f48d5f0285eae1ee8f","modified":1593951124313},{"_id":"source/_posts/决策树构造原理.md","hash":"0443de446bd37b1c2e1b6a1e633b20b9e6fee9ae","modified":1593971576864},{"_id":"source/_posts/常用效率工具1-0.md","hash":"39ff6b1a4176baa69d40d7d89d5798d219e14e74","modified":1593951124318},{"_id":"source/tags/index.md","hash":"c0770e4cf82c2f07a44f26382af9b75d508de7e0","modified":1591557102891},{"_id":"themes/indigo/languages/en.yml","hash":"ba78def0453d08172248e220a1f9e145e99b4f23","modified":1591526964789},{"_id":"themes/indigo/languages/ja.yml","hash":"65a32717335211a45771a21fb7d7778808c6f0aa","modified":1591526964789},{"_id":"themes/indigo/languages/nl-NL","hash":"b540b76af76c1a180c517089ed2ad770cbded170","modified":1591526964789},{"_id":"themes/indigo/languages/zh-CN.yml","hash":"6806e4c305facf19cbe4e37ccc5d6b00cb56e199","modified":1591526964789},{"_id":"themes/indigo/languages/zh-TW.yml","hash":"9b8bdd9c8b68716f364503926dca6ba8571ee5ff","modified":1591526964789},{"_id":"themes/indigo/layout/archive.ejs","hash":"6897178ba358379d6a4b7c0ba1bc2ab97ad5303a","modified":1591526964883},{"_id":"themes/indigo/layout/categories.ejs","hash":"efae06b4d83aaf73ab93260381e891825bf404ac","modified":1591526964883},{"_id":"themes/indigo/layout/category.ejs","hash":"e5ba5cc2e092c199285b8097ef12ffe70bf84c91","modified":1591526964883},{"_id":"themes/indigo/layout/index.ejs","hash":"772c1985c7743e101598b4eddc253f9174c5605b","modified":1591526964883},{"_id":"themes/indigo/layout/layout.ejs","hash":"770af84fff104c398ce8b6c995130cddd3e9a1e9","modified":1591526964883},{"_id":"themes/indigo/layout/page.ejs","hash":"9096f3a7bfbb031887b661f95513638bf45bf6bd","modified":1591555222414},{"_id":"themes/indigo/layout/post.ejs","hash":"efc3352828351f8574c51e8a93dc56c66660c3b1","modified":1591526964899},{"_id":"themes/indigo/layout/tag.ejs","hash":"90a231dea3a364b329a740e5d6c49c8cf5664fe9","modified":1591526964899},{"_id":"themes/indigo/layout/tags.ejs","hash":"1fc0461e9602b53899ec756e4361beb8cce74740","modified":1591526964899},{"_id":"themes/indigo/scripts/plugins.js","hash":"00ea278ea77733f546439aed507ce69a298da362","modified":1591526964899},{"_id":"themes/indigo/source/favicon.ico","hash":"9ff3cb92a6c4312c6af6c8dc96dad32a45c95a9f","modified":1591555222414},{"_id":"source/_posts/决策树构造原理/img02.png","hash":"e3602edb4c7c3d23c4f0292ac332883d2d76408d","modified":1593924409081},{"_id":"source/_posts/决策树构造原理/img03.png","hash":"40d3d27f56236d51a211ad3bccd9df9514716912","modified":1593924439780},{"_id":"source/_posts/决策树构造原理/img04.png","hash":"e8a05de2e14212794008e124750ae77a45a5e543","modified":1593924449836},{"_id":"source/_posts/决策树构造原理/tree.png","hash":"e105623f2a652c25d74f69d30446616b176cf031","modified":1593927007325},{"_id":"source/_posts/决策树构造原理/PlayTennis.png","hash":"e88a2209b78fe7da2bf3fba46f42bdb9123a44a4","modified":1593927980511},{"_id":"themes/indigo/layout/_partial/after-footer.ejs","hash":"1351dbfca311f0d50a939f9e1a91c4f65bbcdf5f","modified":1591526964789},{"_id":"themes/indigo/layout/_partial/archive.ejs","hash":"c294c98617ce14082f9b3d5eec83328f480f5597","modified":1591526964789},{"_id":"themes/indigo/layout/_partial/footer.ejs","hash":"8ed3b3d21ab94a5e1e7c41d11577ccb9c9aaa419","modified":1592124561834},{"_id":"themes/indigo/layout/_partial/head.ejs","hash":"9dfc591ec6c918c5b60b6ccbc5d1e18fea9faf8e","modified":1591526964805},{"_id":"themes/indigo/layout/_partial/loading.ejs","hash":"8b3e037dd5f3d4564012689c5cd6f63caf73df0f","modified":1591526964805},{"_id":"themes/indigo/layout/_partial/header.ejs","hash":"648db446567a81371b8a29d719d13636aa157012","modified":1591526964805},{"_id":"themes/indigo/layout/_partial/index-item.ejs","hash":"7208d4083ee3355aa969972a2ce249a67d56b3a6","modified":1591526964805},{"_id":"themes/indigo/layout/_partial/menu.ejs","hash":"ea6aded24a68de0914f24b3760f766b5e1c9835a","modified":1591526964805},{"_id":"themes/indigo/layout/_partial/paginator.ejs","hash":"13952250463f70d1c1bbbfdd7f4ee8160dd6d99b","modified":1591526964805},{"_id":"themes/indigo/layout/_partial/post.ejs","hash":"20597ac0d547aea37680ecf195eb129fe5ee19d8","modified":1591526964852},{"_id":"themes/indigo/layout/_partial/script.ejs","hash":"b28106b35a9fc63eefa69c2ca8b923eb1f731832","modified":1591526964883},{"_id":"themes/indigo/layout/_partial/search.ejs","hash":"752109904304fdb8e988ee1254df2af9c0701466","modified":1591526964883},{"_id":"themes/indigo/layout/_partial/tags-bar.ejs","hash":"30ec74f081cc4c273a7bcd5d57da99072e9f0755","modified":1591526964883},{"_id":"themes/indigo/source/css/style.less","hash":"cf362925ae099b810fd5763e6b724b823612ed15","modified":1591526965039},{"_id":"themes/indigo/source/img/avatar.jpg","hash":"d7f261bfc317be54e14f6825a26687d8ef9003e9","modified":1591555222414},{"_id":"themes/indigo/source/img/brand.jpg","hash":"0e237f1b433851c156e1f1cdaeb044054b3b9879","modified":1591526965055},{"_id":"themes/indigo/source/img/cc.png","hash":"ebce75a62b40976a72d43f0bd937d859ac24d87c","modified":1591526965055},{"_id":"themes/indigo/source/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1591526965055},{"_id":"themes/indigo/source/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1591526965055},{"_id":"themes/indigo/source/img/wechat.png","hash":"ec5fdc0451e5ef8b33ea6b13f4f0f52463810fe7","modified":1591555222414},{"_id":"themes/indigo/source/js/main.js","hash":"ff44bb7b2f1f08757093fd6ffa92c9ac2b674109","modified":1591526965055},{"_id":"themes/indigo/source/js/main.min.js","hash":"e77a89fe5a9827ac590a288778176b233dd900ad","modified":1591526965055},{"_id":"themes/indigo/source/js/search.js","hash":"a4d6c9c566ec1ca71ddacfd14c58f7ddaf9db24d","modified":1591526965055},{"_id":"themes/indigo/source/js/search.min.js","hash":"a8a450bb8b1ca9ad577052addcbd3393f1af6c6a","modified":1591526965055},{"_id":"themes/indigo/layout/_partial/plugins/baidu.ejs","hash":"da1355eea131952031e54c45560555e6d3aa5a33","modified":1591526964805},{"_id":"themes/indigo/layout/_partial/plugins/dynamic-title.ejs","hash":"3b877868c4a6fc217ea6f3314544830280a77472","modified":1591526964820},{"_id":"themes/indigo/layout/_partial/plugins/disqus.ejs","hash":"86fe837ab16cb60754b0a73bb9efa38b04f3023f","modified":1591526964805},{"_id":"themes/indigo/layout/_partial/plugins/gitalk.ejs","hash":"8a0c390ed475600c627bcfa41df15a54f60eca3c","modified":1591526964820},{"_id":"themes/indigo/layout/_partial/plugins/gitment.ejs","hash":"5f6ceb7f4b9b579e8e3f87894447f556a53f9385","modified":1591526964820},{"_id":"themes/indigo/layout/_partial/plugins/google-analytics.ejs","hash":"b5b87761751a897949e085a8f1ace78b0b8babd5","modified":1591526964820},{"_id":"themes/indigo/layout/_partial/plugins/hyper-comments.ejs","hash":"d0e6f1d713e7a1c0cc5fe25f3e574a4b791f938a","modified":1591526964836},{"_id":"themes/indigo/layout/_partial/plugins/mathjax.ejs","hash":"3a5c9f7d22d30cd8ffa4e83a8d3976db22815994","modified":1591526964836},{"_id":"themes/indigo/layout/_partial/plugins/page-visit.ejs","hash":"bb9deb32c54ea6820f622b923e62592915e9f21f","modified":1591526964836},{"_id":"themes/indigo/layout/_partial/plugins/site-visit.ejs","hash":"a2c247c2e32016563dd6a22c21474072d93f4dbd","modified":1591526964836},{"_id":"themes/indigo/layout/_partial/plugins/tajs.ejs","hash":"ef9c77d8c6e004b014c83c5f9333e7174f8bafa3","modified":1591526964836},{"_id":"themes/indigo/layout/_partial/plugins/uyan.ejs","hash":"ddf290e90dc1c779f42a48e1bd852ca932148dfb","modified":1591526964836},{"_id":"themes/indigo/layout/_partial/plugins/valine.ejs","hash":"0a6245da90d54177441d32a6f1766b4f434660db","modified":1591526964852},{"_id":"themes/indigo/layout/_partial/post/category.ejs","hash":"c08e44cbd7315dec7afb6054b04d3c7b82c3bde8","modified":1591526964852},{"_id":"themes/indigo/layout/_partial/post/copyright.ejs","hash":"dd1dcc7776021ab3d68065f8532efead4c2b8051","modified":1591526964852},{"_id":"themes/indigo/layout/_partial/post/comment.ejs","hash":"2751d0f694f72bb886664ace021d698ea0e8f0c7","modified":1591526964852},{"_id":"themes/indigo/layout/_partial/post/date.ejs","hash":"c5adcec8db1506c378d39855a697e1bb1165646c","modified":1591526964852},{"_id":"themes/indigo/layout/_partial/post/head-meta.ejs","hash":"f137c126672769e9571be2bb0a70ea8dda644b0e","modified":1591526964852},{"_id":"themes/indigo/layout/_partial/post/nav.ejs","hash":"03719097851575a2c1bb95774058b224f6402a1f","modified":1591526964852},{"_id":"themes/indigo/layout/_partial/post/reward-btn.ejs","hash":"b46160005224821a439dec9f1ff183e2f66d9f4b","modified":1591526964883},{"_id":"themes/indigo/layout/_partial/post/reward.ejs","hash":"097c0276a61665e5ee96e5d5d85a7d6ae5ab2f49","modified":1591526964883},{"_id":"themes/indigo/layout/_partial/post/share-fab.ejs","hash":"2ec7de870988cfbc8ea9872cddf7e4076ac64a57","modified":1591526964883},{"_id":"themes/indigo/layout/_partial/post/share.ejs","hash":"7d79a67b3e5e6989f22fb0e0904fa540bfca5fcc","modified":1591526964883},{"_id":"themes/indigo/layout/_partial/post/tag.ejs","hash":"412894001b1ac6e63012b26b1109a0856651c076","modified":1591526964883},{"_id":"themes/indigo/layout/_partial/post/title.ejs","hash":"eaad7af7888bddd7095243a43ff38f55ad8c494a","modified":1591526964883},{"_id":"themes/indigo/layout/_partial/post/toc.ejs","hash":"d534b888d24df7703c632539d4bdd638fa764e98","modified":1591526964883},{"_id":"themes/indigo/layout/_partial/post/updated.ejs","hash":"00fedf7971c0bda0623d968bc0614e512d19a985","modified":1591526964883},{"_id":"themes/indigo/source/css/_partial/archives.less","hash":"382fc22cd5cc073e881768a65600d97eba9f1d21","modified":1591526964899},{"_id":"themes/indigo/source/css/_partial/article.less","hash":"f047c8ca92f9e6a8e1299ace0cce91514631a21c","modified":1591526964899},{"_id":"themes/indigo/source/css/_partial/gotop.less","hash":"bad63006b3bd4849bf53ad38482af0d9971061d3","modified":1591526964899},{"_id":"themes/indigo/source/css/_partial/header.less","hash":"880b4a28e97d556ed15b07642d25115f9b6ba4f6","modified":1591526964899},{"_id":"themes/indigo/source/css/_partial/highlight.less","hash":"99e48793dc0b4ffb66ecaf2d1315145872f9bb98","modified":1591526964899},{"_id":"themes/indigo/source/css/_partial/layout.less","hash":"5f783f34bf093e654e8922ed4a2af8b7b2cd41c4","modified":1591526964899},{"_id":"themes/indigo/source/css/_partial/lightbox.less","hash":"38419aaf3c1832e84ade331f051f110fdc8b960f","modified":1591526964914},{"_id":"themes/indigo/source/css/_partial/loading.less","hash":"85157ddf3877b5c58e8f1d737dda3dfb1bfd540b","modified":1591526964914},{"_id":"themes/indigo/source/css/_partial/page.less","hash":"33b0a5edcedc26a4c592c812c5785bb20d3c93db","modified":1591526964914},{"_id":"themes/indigo/source/css/_partial/reward.less","hash":"f5e89ea5414e3096a28c8c96e86c3f669040a892","modified":1591526964914},{"_id":"themes/indigo/source/css/_partial/postlist.less","hash":"516cded3c7f1db4cacfa898bcaf0adfae7f3a2e1","modified":1591526964914},{"_id":"themes/indigo/source/css/_partial/roboto.less","hash":"3e457942995da8840e7662fa6cb551a7e12ea294","modified":1591526964914},{"_id":"themes/indigo/source/css/_partial/search.less","hash":"dbc23e77e586ee682a21475f5eb568628ea6720f","modified":1591526964914},{"_id":"themes/indigo/source/css/_partial/share.less","hash":"a683c96a59470efd35722b763c55149a46e35156","modified":1591526964914},{"_id":"themes/indigo/source/css/_partial/tags.less","hash":"01eb7f84193180928a6ed4796ee8802f6c1628e7","modified":1591526964914},{"_id":"themes/indigo/source/css/_partial/variable.less","hash":"3232e75f4653402c9fbd7bda5b97c05ecc31db2b","modified":1591526964914},{"_id":"themes/indigo/source/css/_partial/waves.less","hash":"a02eaa601887f947257f6016679b62dc96a61c0c","modified":1591526964914},{"_id":"themes/indigo/source/css/_plugin/valine.less","hash":"b8f8d8037fb3c8525da12e580bd9e2ff9f298132","modified":1591526964914},{"_id":"themes/indigo/source/css/_partial/fontawesome.less","hash":"a3ecbd6ccf5b56ac39df710c34a149b82989a498","modified":1591526964899},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.eot","hash":"a76cd602f5188b9fbd4ba7443dcb9c064e3dbf10","modified":1591526964961},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff","hash":"ee99cd87a59a9a5d4092c83232bb3eec67547425","modified":1591526964977},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff2","hash":"933b866d09c2b087707a98dab64b3888865eeb96","modified":1591526964977},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.eot","hash":"42fe156996197e5eb0c0264c5d1bb3b4681f4595","modified":1591526964977},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff2","hash":"bbdc28b887400fcb340b504ec2904993af42a5d7","modified":1591526965008},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.eot","hash":"1517f4b6e1c5d0e5198f937557253aac8fab0416","modified":1591526965024},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff2","hash":"6cc1b73571af9e827c4e7e91418f476703cd4c4b","modified":1591526965024},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.eot","hash":"77ae3e980ec03863ebe2587a8ef9ddfd06941db0","modified":1591526965024},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff","hash":"74734dde8d94e7268170f9b994dedfbdcb5b3a15","modified":1591526965039},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff2","hash":"ed1558b0541f5e01ce48c7db1588371b990eec19","modified":1591526965039},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.eot","hash":"0790a51a848dbe7292c98f9d0459218bf1a8ffdd","modified":1591526965039},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff","hash":"fbc3e71d456c96667d8082ab910e3946ef89240b","modified":1591526965039},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff2","hash":"2449e3dac5ddb7c3da8bb07450493b62d052758c","modified":1591526965039},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1591526964945},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1591526964961},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff","hash":"6300f659be9e834ab263efe2fb3c581d48b1e7b2","modified":1591526965008},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff","hash":"d45f84922131364989ad6578c7a06b6b4fc22c34","modified":1591526965024},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.ttf","hash":"824b5480c977a8166e177e5357d13164ccc45f47","modified":1591526965024},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.ttf","hash":"173ed64528b4d010a76d8d38deb1d7e7eed58eda","modified":1591526965039},{"_id":"themes/indigo/source/css/fonts/fontawesome/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1591526964914},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1591526964930},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1591526964945},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.ttf","hash":"47327df0f35e7cd7c8645874897a7449697544ae","modified":1591526964977},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.ttf","hash":"e321c183e2b75ee19813892b7bac8d7c411cb88a","modified":1591526965008},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.ttf","hash":"6060ca726b9760b76f7c347dce9d2fa1fe42ec92","modified":1591526965024},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1591526964930},{"_id":"public/atom.xml","hash":"9872dbd44138e4196bae54a85fd91cc777e48086","modified":1593971635447},{"_id":"public/content.json","hash":"2d378cb6283c653b492a778b11980004780dc46c","modified":1593971635447},{"_id":"public/404.html","hash":"5892c283d87253388eeedb3d027d501733a3063e","modified":1593971635447},{"_id":"public/archives/page/2/index.html","hash":"0729cdec9319a4b60e99574bedd8e30904453406","modified":1593971635447},{"_id":"public/archives/2020/page/2/index.html","hash":"c99a5f1a4b79350118269621218e8110e4c51955","modified":1593971635447},{"_id":"public/archives/2020/07/index.html","hash":"e4cd3ae595a9c7ece632021395bc83d383d0ed6f","modified":1593971635447},{"_id":"public/categories/博客/index.html","hash":"5446833b705857ba76de01b9ee7bfc02e3ab31b7","modified":1593971635447},{"_id":"public/categories/Java/index.html","hash":"bc055bb9c16b068eaf8d9b9a82e4e769954647d7","modified":1593971635447},{"_id":"public/categories/大数据/index.html","hash":"de6a3db5de6d65e1448419b80efe33cee7e33e39","modified":1593971635447},{"_id":"public/categories/算法/index.html","hash":"1fcd75ae881b4e9423b78601b2304eaf8661e21c","modified":1593971635447},{"_id":"public/categories/理论/index.html","hash":"8990775a415cbfea557a548fca5956c6cc5f1a56","modified":1593971635447},{"_id":"public/categories/工具/index.html","hash":"40334412ac1363d7c44fd15bfd6a03d3b084c3cc","modified":1593971635447},{"_id":"public/page/2/index.html","hash":"ee785e00ce5a7ba9305b05bc6d031807dbe522cb","modified":1593971635447},{"_id":"public/tags/HashMap/index.html","hash":"dc91b2f5cc5023594ba749bbb6e3ee625729a034","modified":1593971635447},{"_id":"public/tags/Hexo/index.html","hash":"5282e84bfb06929e08c99cf1af49eae6e722c8d4","modified":1593971635447},{"_id":"public/tags/Travis-CI/index.html","hash":"c70efabf0f3d8ec8feb06fd2fc92fef1264693cd","modified":1593971635447},{"_id":"public/tags/Java/index.html","hash":"e2e7811469cad03248345fdd2288f140ba5b47f9","modified":1593971635447},{"_id":"public/tags/锁/index.html","hash":"b3bad9035a9cf0721ee7513395270d138faf0561","modified":1593971635447},{"_id":"public/tags/多线程/index.html","hash":"c9c03ec0db7bc6c5d75c7fd14ca2642642da7bbc","modified":1593971635447},{"_id":"public/tags/Hive/index.html","hash":"0f0d9e69ff8dde8fc14275a044b31c456fa8718d","modified":1593971635447},{"_id":"public/tags/PLDA/index.html","hash":"87fba5bc10f45e0b6f7f1eb8944b2cf2e169fa55","modified":1593971635447},{"_id":"public/tags/信息/index.html","hash":"c64181890b0ea3eb4f28eec513736efa48183b88","modified":1593971635447},{"_id":"public/tags/熵/index.html","hash":"3f305ef4e93a4104f2bae6d76731fb47b9884783","modified":1593971635447},{"_id":"public/tags/开发规范/index.html","hash":"63453e1e7e51232fba7214f871bb5dd695b00510","modified":1593971635447},{"_id":"public/tags/决策树/index.html","hash":"92e95c64dff224654d04b13d78ce2cce05e655b9","modified":1593971635447},{"_id":"public/tags/开发/index.html","hash":"f1ebee19e070e1008ed6421971d053e7530423f6","modified":1593971635447},{"_id":"public/categories/index.html","hash":"4fc6ad3cecf8ec02ed2aac196ec003324ecb7c5a","modified":1593971635447},{"_id":"public/tags/index.html","hash":"46d59f0911a74f12721e4782cb8bb8b1cc310252","modified":1593971635447},{"_id":"public/posts/257cbae6.html","hash":"bd42e6e733e7ba8d97a61ceac1a32e7eac03abdd","modified":1593971635447},{"_id":"public/posts/10a08d6a.html","hash":"96528cca034606db4321543f239326c67f4f7843","modified":1593971635447},{"_id":"public/posts/c013043.html","hash":"a74ab1281283c866c583ffb11af0b897cfbef02d","modified":1593971635447},{"_id":"public/posts/c0c98174.html","hash":"ba31023b183ca45b96e759ce5337cad693234248","modified":1593971635447},{"_id":"public/posts/ddb1142c.html","hash":"38fa5a9ee068d11967ea3b42ae85af30830723e5","modified":1593971635447},{"_id":"public/posts/acf44460.html","hash":"974284e9178d87af974e05fc33d2659aff6c9992","modified":1593971635447},{"_id":"public/posts/72ac77ba.html","hash":"f8db24a94192494614e0c558fbb7841c8521cd56","modified":1593971635447},{"_id":"public/posts/16f679cd.html","hash":"7b59d07fb533a480193e92e9b527d2751f5c71ed","modified":1593971635447},{"_id":"public/posts/aab15d5f.html","hash":"8cb057ea58883549894631055da8ba9a72de2f11","modified":1593971635447},{"_id":"public/posts/667634fc.html","hash":"da788d04d48e334cb6a54f794bf9d4d9db7dd0be","modified":1593971635447},{"_id":"public/posts/4a17b156.html","hash":"796ffa7f09ae8eb2185451cf5d75c38ad70cdb00","modified":1593971635447},{"_id":"public/archives/index.html","hash":"f821c51a73c2a23394a0e69675b79b3bff7cd827","modified":1593971635447},{"_id":"public/archives/2020/index.html","hash":"54a07c46a9cc810a93119c0dc435149e5a31c15f","modified":1593971635447},{"_id":"public/archives/2020/06/index.html","hash":"e1ce2bd34e2f1a0f31c1cb6aeb896c336f3a4de6","modified":1593971635447},{"_id":"public/index.html","hash":"9c010d942e620cff45a34e682eb229063f19cba8","modified":1593971635447},{"_id":"public/favicon.ico","hash":"9ff3cb92a6c4312c6af6c8dc96dad32a45c95a9f","modified":1593971635447},{"_id":"public/img/avatar.jpg","hash":"d7f261bfc317be54e14f6825a26687d8ef9003e9","modified":1593971635447},{"_id":"public/img/cc.png","hash":"ebce75a62b40976a72d43f0bd937d859ac24d87c","modified":1593971635447},{"_id":"public/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1593971635447},{"_id":"public/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1593971635447},{"_id":"public/css/fonts/roboto/Roboto-Bold.eot","hash":"a76cd602f5188b9fbd4ba7443dcb9c064e3dbf10","modified":1593971635447},{"_id":"public/css/fonts/roboto/Roboto-Medium.eot","hash":"1517f4b6e1c5d0e5198f937557253aac8fab0416","modified":1593971635447},{"_id":"public/css/fonts/roboto/Roboto-Regular.eot","hash":"77ae3e980ec03863ebe2587a8ef9ddfd06941db0","modified":1593971635447},{"_id":"public/css/fonts/roboto/Roboto-Thin.eot","hash":"0790a51a848dbe7292c98f9d0459218bf1a8ffdd","modified":1593971635447},{"_id":"public/css/fonts/roboto/Roboto-Medium.woff2","hash":"6cc1b73571af9e827c4e7e91418f476703cd4c4b","modified":1593971635447},{"_id":"public/css/fonts/roboto/Roboto-Regular.woff2","hash":"ed1558b0541f5e01ce48c7db1588371b990eec19","modified":1593971635447},{"_id":"public/css/fonts/roboto/Roboto-Thin.woff2","hash":"2449e3dac5ddb7c3da8bb07450493b62d052758c","modified":1593971635447},{"_id":"public/posts/257cbae6/img02.png","hash":"e3602edb4c7c3d23c4f0292ac332883d2d76408d","modified":1593971635447},{"_id":"public/posts/257cbae6/img03.png","hash":"40d3d27f56236d51a211ad3bccd9df9514716912","modified":1593971635447},{"_id":"public/posts/257cbae6/img04.png","hash":"e8a05de2e14212794008e124750ae77a45a5e543","modified":1593971635447},{"_id":"public/posts/257cbae6/tree.png","hash":"e105623f2a652c25d74f69d30446616b176cf031","modified":1593971635447},{"_id":"public/img/brand.jpg","hash":"0e237f1b433851c156e1f1cdaeb044054b3b9879","modified":1593971635447},{"_id":"public/img/wechat.png","hash":"ec5fdc0451e5ef8b33ea6b13f4f0f52463810fe7","modified":1593971635447},{"_id":"public/css/fonts/roboto/Roboto-Bold.woff","hash":"ee99cd87a59a9a5d4092c83232bb3eec67547425","modified":1593971635447},{"_id":"public/css/fonts/roboto/Roboto-Light.woff2","hash":"bbdc28b887400fcb340b504ec2904993af42a5d7","modified":1593971635447},{"_id":"public/css/fonts/roboto/Roboto-Bold.woff2","hash":"933b866d09c2b087707a98dab64b3888865eeb96","modified":1593971635447},{"_id":"public/css/fonts/roboto/Roboto-Light.eot","hash":"42fe156996197e5eb0c0264c5d1bb3b4681f4595","modified":1593971635447},{"_id":"public/css/fonts/roboto/Roboto-Thin.woff","hash":"fbc3e71d456c96667d8082ab910e3946ef89240b","modified":1593971635447},{"_id":"public/css/fonts/roboto/Roboto-Regular.woff","hash":"74734dde8d94e7268170f9b994dedfbdcb5b3a15","modified":1593971635447},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1593971635447},{"_id":"public/css/fonts/roboto/Roboto-Medium.woff","hash":"d45f84922131364989ad6578c7a06b6b4fc22c34","modified":1593971635447},{"_id":"public/css/fonts/roboto/Roboto-Light.woff","hash":"6300f659be9e834ab263efe2fb3c581d48b1e7b2","modified":1593971635447},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1593971635447},{"_id":"public/css/fonts/roboto/Roboto-Thin.ttf","hash":"173ed64528b4d010a76d8d38deb1d7e7eed58eda","modified":1593971635447},{"_id":"public/css/fonts/roboto/Roboto-Bold.ttf","hash":"47327df0f35e7cd7c8645874897a7449697544ae","modified":1593971635447},{"_id":"public/css/fonts/roboto/Roboto-Light.ttf","hash":"e321c183e2b75ee19813892b7bac8d7c411cb88a","modified":1593971635447},{"_id":"public/css/fonts/roboto/Roboto-Medium.ttf","hash":"6060ca726b9760b76f7c347dce9d2fa1fe42ec92","modified":1593971635447},{"_id":"public/posts/257cbae6/PlayTennis.png","hash":"e88a2209b78fe7da2bf3fba46f42bdb9123a44a4","modified":1593971635447},{"_id":"public/js/main.min.js","hash":"8acf4480f8ab859423b8926b9b790c67b5a77276","modified":1593971635447},{"_id":"public/js/search.min.js","hash":"a8a450bb8b1ca9ad577052addcbd3393f1af6c6a","modified":1593971635447},{"_id":"public/js/search.js","hash":"a1de7e7a2ef8330ebcd9f3a7a4622b3bac44e4f3","modified":1593971635447},{"_id":"public/js/main.js","hash":"300b2e963683ced162e28afcd24ffc970fc23ac2","modified":1593971635447},{"_id":"public/css/fonts/roboto/Roboto-Regular.ttf","hash":"824b5480c977a8166e177e5357d13164ccc45f47","modified":1593971635447},{"_id":"public/css/fonts/fontawesome/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1593971635447},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1593971635447},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1593971635447},{"_id":"public/css/style.css","hash":"4f59712181405c963fe7e80740071022050bc096","modified":1593971635447},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1593971635447}],"Category":[{"name":"Java","_id":"ckc9dk3bt0004nsvnf5hyhahy"},{"name":"博客","_id":"ckc9dk3c60009nsvn17z1ce8i"},{"name":"大数据","_id":"ckc9dk3cq000jnsvnc679gbba"},{"name":"算法","_id":"ckc9dk3cz000rnsvna514bvnb"},{"name":"理论","_id":"ckc9dk3d2000vnsvnau60a854"},{"name":"工具","_id":"ckc9dk3d70011nsvnc132e32v"}],"Data":[],"Page":[{"layout":"true","comments":0,"title":"Page not found | 404","_content":"","source":"404.html","raw":"layout: true\ncomments: false\ntitle: \"Page not found | 404\"\n---\n","date":"2020-06-08T13:00:55.378Z","updated":"2020-06-08T12:58:14.992Z","path":"404.html","_id":"ckc9dk39c0000nsvn0i5fbxjl","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","layout":"categories","comments":0,"date":"2020-06-07T11:21:55.000Z","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\nlayout: categories\ncomments: false\ndate: 2020-06-07 19:21:55\n---\n","updated":"2020-06-07T19:12:20.662Z","path":"categories/index.html","_id":"ckc9dk3bh0001nsvnhhib1iks","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","layout":"tags","comments":0,"date":"2020-06-07T11:20:55.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\nlayout: tags\ncomments: false\ndate: 2020-06-07 19:20:55\n---\n","updated":"2020-06-07T19:11:42.891Z","path":"tags/index.html","_id":"ckc9dk3el001onsvnb47qai4i","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"HashMap常用操作","abbrlink":"10a08d6a","date":"2020-06-29T11:56:28.000Z","_content":"\n### HashMap带默认值操作\n\n> public V getOrDefault(Object key, V defaultValue)\n\n返回指定键所映射到的值；如果此映射不包含键的映射关系，则返回defaultValue。\n\n```java\nHashMap<String, Integer> map = new HashMap<>();\nmap.put(\"a\", 200);\n\n// key = a 存在，返回值 k = 200\nInteger k = map.getOrDefault(\"a\", 500);\n\n// key = b 不存在，返回默认值 h = 500\nInteger h = map.getOrDefault(\"b\", 500);\n```\n\n> public V putIfAbsent(K key, V value)\n\n如果指定的键尚未与值关联（或映射为null），则将其与给定值关联并返回null，否则返回当前值。\n\n```java\nHashMap<String, Integer> map = new HashMap<>();\nmap.put(\"a\", 200);\nmap.put(\"e\", null);\n\n// key = b 不存在，则相当于执行 put(\"b\", 500)，并返回 k = null\nInteger k = map.putIfAbsent(\"b\", 500);\n\n// key = b 存在，但 value = null，则相当于执行 put(\"e\", 500)，并返回 h = null\nInteger h = map.putIfAbsent(\"e\", 500);\n\n// key = a 存在，且 value != null, 则 原值不变，返回 f = 200\nInteger f = map.putIfAbsent(\"a\", 500);\n```\n\n### HashMap四种遍历方式\n\n```java\n//第一种: 通过Map.keySet遍历key和value\nfor (String key: map.keySet()) {\n\tSystem.out.println(\"key= \" + key + \" and value= \" + map.get(key));\n}\n\n//第二种: 通过Map.entrySet使用iterator遍历key和value\nIterator < Map.Entry < String, String >> it = map.entrySet().iterator();\nwhile (it.hasNext()) {\n\tMap.Entry < String, String > entry = it.next();\n\tSystem.out.println(\"key= \" + entry.getKey() + \" and value= \" + entry.getValue());\n}\n\n//第三种: 推荐，尤其是容量大时, 通过Map.entrySet遍历key和value\nfor (Map.Entry < String, String > entry: map.entrySet()) {\n\tSystem.out.println(\"key= \" + entry.getKey() + \" and value= \" + entry.getValue());\n}\n\n//第四种: 通过Map.values()遍历所有的value, 但不能遍历key\nfor (String v: map.values()) {\n\tSystem.out.println(\"value= \" + v);\n}\n```\n","source":"_posts/HashMap常用操作.md","raw":"---\ntitle: HashMap常用操作\ncategories: Java\ntags: HashMap\nabbrlink: 10a08d6a\ndate: 2020-06-29 19:56:28\n---\n\n### HashMap带默认值操作\n\n> public V getOrDefault(Object key, V defaultValue)\n\n返回指定键所映射到的值；如果此映射不包含键的映射关系，则返回defaultValue。\n\n```java\nHashMap<String, Integer> map = new HashMap<>();\nmap.put(\"a\", 200);\n\n// key = a 存在，返回值 k = 200\nInteger k = map.getOrDefault(\"a\", 500);\n\n// key = b 不存在，返回默认值 h = 500\nInteger h = map.getOrDefault(\"b\", 500);\n```\n\n> public V putIfAbsent(K key, V value)\n\n如果指定的键尚未与值关联（或映射为null），则将其与给定值关联并返回null，否则返回当前值。\n\n```java\nHashMap<String, Integer> map = new HashMap<>();\nmap.put(\"a\", 200);\nmap.put(\"e\", null);\n\n// key = b 不存在，则相当于执行 put(\"b\", 500)，并返回 k = null\nInteger k = map.putIfAbsent(\"b\", 500);\n\n// key = b 存在，但 value = null，则相当于执行 put(\"e\", 500)，并返回 h = null\nInteger h = map.putIfAbsent(\"e\", 500);\n\n// key = a 存在，且 value != null, 则 原值不变，返回 f = 200\nInteger f = map.putIfAbsent(\"a\", 500);\n```\n\n### HashMap四种遍历方式\n\n```java\n//第一种: 通过Map.keySet遍历key和value\nfor (String key: map.keySet()) {\n\tSystem.out.println(\"key= \" + key + \" and value= \" + map.get(key));\n}\n\n//第二种: 通过Map.entrySet使用iterator遍历key和value\nIterator < Map.Entry < String, String >> it = map.entrySet().iterator();\nwhile (it.hasNext()) {\n\tMap.Entry < String, String > entry = it.next();\n\tSystem.out.println(\"key= \" + entry.getKey() + \" and value= \" + entry.getValue());\n}\n\n//第三种: 推荐，尤其是容量大时, 通过Map.entrySet遍历key和value\nfor (Map.Entry < String, String > entry: map.entrySet()) {\n\tSystem.out.println(\"key= \" + entry.getKey() + \" and value= \" + entry.getValue());\n}\n\n//第四种: 通过Map.values()遍历所有的value, 但不能遍历key\nfor (String v: map.values()) {\n\tSystem.out.println(\"value= \" + v);\n}\n```\n","slug":"HashMap常用操作","published":1,"updated":"2020-07-05T12:12:04.257Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc9dk3bj0002nsvna6hog06h","content":"<h3 id=\"HashMap带默认值操作\"><a href=\"#HashMap带默认值操作\" class=\"headerlink\" title=\"HashMap带默认值操作\"></a>HashMap带默认值操作</h3><blockquote>\n<p>public V getOrDefault(Object key, V defaultValue)</p>\n</blockquote>\n<p>返回指定键所映射到的值；如果此映射不包含键的映射关系，则返回defaultValue。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HashMap&lt;String, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">map.put(<span class=\"string\">\"a\"</span>, <span class=\"number\">200</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// key = a 存在，返回值 k = 200</span></span><br><span class=\"line\">Integer k = map.getOrDefault(<span class=\"string\">\"a\"</span>, <span class=\"number\">500</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// key = b 不存在，返回默认值 h = 500</span></span><br><span class=\"line\">Integer h = map.getOrDefault(<span class=\"string\">\"b\"</span>, <span class=\"number\">500</span>);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>public V putIfAbsent(K key, V value)</p>\n</blockquote>\n<p>如果指定的键尚未与值关联（或映射为null），则将其与给定值关联并返回null，否则返回当前值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HashMap&lt;String, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">map.put(<span class=\"string\">\"a\"</span>, <span class=\"number\">200</span>);</span><br><span class=\"line\">map.put(<span class=\"string\">\"e\"</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// key = b 不存在，则相当于执行 put(\"b\", 500)，并返回 k = null</span></span><br><span class=\"line\">Integer k = map.putIfAbsent(<span class=\"string\">\"b\"</span>, <span class=\"number\">500</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// key = b 存在，但 value = null，则相当于执行 put(\"e\", 500)，并返回 h = null</span></span><br><span class=\"line\">Integer h = map.putIfAbsent(<span class=\"string\">\"e\"</span>, <span class=\"number\">500</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// key = a 存在，且 value != null, 则 原值不变，返回 f = 200</span></span><br><span class=\"line\">Integer f = map.putIfAbsent(<span class=\"string\">\"a\"</span>, <span class=\"number\">500</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HashMap四种遍历方式\"><a href=\"#HashMap四种遍历方式\" class=\"headerlink\" title=\"HashMap四种遍历方式\"></a>HashMap四种遍历方式</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//第一种: 通过Map.keySet遍历key和value</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (String key: map.keySet()) &#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">\"key= \"</span> + key + <span class=\"string\">\" and value= \"</span> + map.get(key));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//第二种: 通过Map.entrySet使用iterator遍历key和value</span></span><br><span class=\"line\">Iterator &lt; Map.Entry &lt; String, String &gt;&gt; it = map.entrySet().iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (it.hasNext()) &#123;</span><br><span class=\"line\">\tMap.Entry &lt; String, String &gt; entry = it.next();</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">\"key= \"</span> + entry.getKey() + <span class=\"string\">\" and value= \"</span> + entry.getValue());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//第三种: 推荐，尤其是容量大时, 通过Map.entrySet遍历key和value</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (Map.Entry &lt; String, String &gt; entry: map.entrySet()) &#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">\"key= \"</span> + entry.getKey() + <span class=\"string\">\" and value= \"</span> + entry.getValue());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//第四种: 通过Map.values()遍历所有的value, 但不能遍历key</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (String v: map.values()) &#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">\"value= \"</span> + v);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"HashMap带默认值操作\"><a href=\"#HashMap带默认值操作\" class=\"headerlink\" title=\"HashMap带默认值操作\"></a>HashMap带默认值操作</h3><blockquote>\n<p>public V getOrDefault(Object key, V defaultValue)</p>\n</blockquote>\n<p>返回指定键所映射到的值；如果此映射不包含键的映射关系，则返回defaultValue。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HashMap&lt;String, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">map.put(<span class=\"string\">\"a\"</span>, <span class=\"number\">200</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// key = a 存在，返回值 k = 200</span></span><br><span class=\"line\">Integer k = map.getOrDefault(<span class=\"string\">\"a\"</span>, <span class=\"number\">500</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// key = b 不存在，返回默认值 h = 500</span></span><br><span class=\"line\">Integer h = map.getOrDefault(<span class=\"string\">\"b\"</span>, <span class=\"number\">500</span>);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>public V putIfAbsent(K key, V value)</p>\n</blockquote>\n<p>如果指定的键尚未与值关联（或映射为null），则将其与给定值关联并返回null，否则返回当前值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HashMap&lt;String, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">map.put(<span class=\"string\">\"a\"</span>, <span class=\"number\">200</span>);</span><br><span class=\"line\">map.put(<span class=\"string\">\"e\"</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// key = b 不存在，则相当于执行 put(\"b\", 500)，并返回 k = null</span></span><br><span class=\"line\">Integer k = map.putIfAbsent(<span class=\"string\">\"b\"</span>, <span class=\"number\">500</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// key = b 存在，但 value = null，则相当于执行 put(\"e\", 500)，并返回 h = null</span></span><br><span class=\"line\">Integer h = map.putIfAbsent(<span class=\"string\">\"e\"</span>, <span class=\"number\">500</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// key = a 存在，且 value != null, 则 原值不变，返回 f = 200</span></span><br><span class=\"line\">Integer f = map.putIfAbsent(<span class=\"string\">\"a\"</span>, <span class=\"number\">500</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HashMap四种遍历方式\"><a href=\"#HashMap四种遍历方式\" class=\"headerlink\" title=\"HashMap四种遍历方式\"></a>HashMap四种遍历方式</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//第一种: 通过Map.keySet遍历key和value</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (String key: map.keySet()) &#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">\"key= \"</span> + key + <span class=\"string\">\" and value= \"</span> + map.get(key));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//第二种: 通过Map.entrySet使用iterator遍历key和value</span></span><br><span class=\"line\">Iterator &lt; Map.Entry &lt; String, String &gt;&gt; it = map.entrySet().iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (it.hasNext()) &#123;</span><br><span class=\"line\">\tMap.Entry &lt; String, String &gt; entry = it.next();</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">\"key= \"</span> + entry.getKey() + <span class=\"string\">\" and value= \"</span> + entry.getValue());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//第三种: 推荐，尤其是容量大时, 通过Map.entrySet遍历key和value</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (Map.Entry &lt; String, String &gt; entry: map.entrySet()) &#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">\"key= \"</span> + entry.getKey() + <span class=\"string\">\" and value= \"</span> + entry.getValue());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//第四种: 通过Map.values()遍历所有的value, 但不能遍历key</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (String v: map.values()) &#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">\"value= \"</span> + v);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"GitHub Pages+Hexo+Travis CI-自动化构建的静态博客","toc":true,"abbrlink":"aab15d5f","date":"2020-06-08T13:22:55.000Z","_content":"\n### 博客说明📝\n\n1. 博客托管于GitHub Pages，使用Hexo作为博客框架，使用Travis CI完成自动构建。\n2. 博客源码放在master分支，编译生成的静态文件放在gh-pages分支。\n3. 每次写完文章后push到master上，Travis CI会自动编译出静态文件并部署到gh-pages分支。\n4. 因为有Travis CI帮助生成和部署，所以可以在Github上直接编辑文章了。\n5. 通过本博客左侧 build status链接可以看到每次构建的过程。\n\n### 搭建步骤📐\n\n>环境：Windows 10\n\n#### 1.本地安装Node.js，Git\n\n#### 2.在GitHub新建repository\n\n这里有两种创建方式，对应的GitHub pages地址也不一样：\n\n①仓库名为fuos.github.io（`GitHub pages`）\nHexo生成的静态博客文件需要放在master分支，博客地址为 fuos.github.io\n\n②仓库名为my-blog或者其他任意名称（`Project pages`，本博客采用这种方式）\nHexo生成的静态文件需要放在gh-pages分支，博客地址为 fuos.github.io/my-blog\n\n#### 3.安装Hexo\n\n本地安装和初始化Hexo，<folder>为任意名称，如my-blog：\n\n``` bash\n$ npm install -g hexo-cli\n$ hexo init <folder>\n$ cd <folder>\n$ npm install\n```\n\n#### 4.安装theme🎨\n\n本博客选择 indigo 作为主题，并对其中部分内容根据需要做了修改。具体安装和配置请参考官方文档：[文档 | Document](https://github.com/yscoder/hexo-theme-indigo/wiki)\n\n这里主要修改了三个地方：\n\n①page-about-me跳转地址\n\n由于我创建的仓库是第二种，所以需要对`themes/indigo/layout/page.ejs`做相应的修改（第二行为修改后）\n\n```javascript\n<a href=\"/\" class=\"avatar waves-effect waves-circle waves-light\"><%- image_tag(theme.avatar) %></a>\n<a href=\"<%- config.url %>\" class=\"avatar waves-effect waves-circle waves-light\"><%- image_tag(theme.avatar) %></a>\n```\n\n②启用gitalk评论插件\n\nowner为github account，repo为刚才创建的用于存放博客的repository，GitHub Application在 Settings -> Developer settings -> OAuth Apps申请\n\n```yaml\n# use gitalk://github.com/gitalk/gitalk\ngitalk: \n  owner: fuos\n  repo: my-blog\n  client_id: 'GitHub Application Client ID'\n  client_secret: 'GitHub Application Client Secret'\n```\n\n③优化文章永久链接\n\n进入my-blog安装插件：\n\n```bash\n$ npm install hexo-abbrlink --save\n```\n\n修改_config.yml下permalink信息：\n\n```bash\n# permalink: :year/:month/:day/:title/\n# permalink_defaults:\npermalink: posts/:abbrlink.html\n# abbrlink config\nabbrlink:\n  alg: crc32  #support crc16(default) and crc32\n  rep: hex    #support dec(default) and hex\n```\n#### 5.推送分支\n\n这里将本地博客源文件推送到了master分支\n\n```bash\ncd my-blog \ngit init \ngit remote add origin git@github.com:fuos/my-blog.git\ngit add . \ngit commit -am \"init blog\" \n# 推送到master\ngit push -u origin master\n```\n\n#### 6.使用 Travis CI 构建和部署\n\n①使用GitHub账号登陆[Travis CI](https://travis-ci.org/)，在github中创建access token，在Travis CI你的repository页面Environment Variables新建环境变量，name为GH_TOKEN，Value 为刚才你在 GitHub 生成的 Token\n\n②在my-blog下新建.travis.yml文件，添加下面的内容：\n\n```yaml\nsudo: false\nlanguage: node_js\nnode_js:\n  - 10 # use nodejs v10 LTS\ncache: npm\nbranches:\n  only:\n    - master # build master branch only\nscript:\n  - hexo generate # generate static files\ndeploy:\n  provider: pages\n  skip-cleanup: true\n  github-token: $GH_TOKEN\n  keep-history: true\n  on:\n    branch: master\n  local-dir: public\n```\n\n③修改my-blog下_config.yml中deploy部分\n\n```yaml\ndeploy:\n  type: git\n  # repo: https://github.com/<username>/<project>\n  # example, https://github.com/hexojs/hexojs.github.io\n  # Hexo静态文件默认推送到gh-pages分支\n  branch: gh-pages\n```\n\n④将修改推送到远端master\n\n```bash\ngit add .\ngit commit -m \"add travis ci\"\ngit push origin master\n```\n\n这样配置之后，Hexo已经能够自动构建和部署了，可以到travis-ci中看到[Job log](https://travis-ci.org/github/fuos/my-blog/jobs/696306109)\n\n之后写文章时可以按照下面的步骤新建和提交， Travis CI 会将Hexo生成的静态文件自动部署到gh-pages分支。\n\n```bash\ncd my-blog \ngit checkout master \nhexo new \"My First Post - Test\" \ngit add . \ngit commit -am\"add test post\" \ngit push\n```\n\n💾博客源码：https://github.com/fuos/my-blog\n\n⚙Travis CI：https://travis-ci.org/github/fuos/my-blog\n\n\n\n","source":"_posts/GitHub Pages+Hexo+Travis CI-自动化构建的静态博客.md","raw":"---\ntitle: GitHub Pages+Hexo+Travis CI-自动化构建的静态博客\ntags:\n  - Hexo\n  - Travis CI\ncategories: 博客\ntoc: true\nabbrlink: aab15d5f\ndate: 2020-06-08 21:22:55\n---\n\n### 博客说明📝\n\n1. 博客托管于GitHub Pages，使用Hexo作为博客框架，使用Travis CI完成自动构建。\n2. 博客源码放在master分支，编译生成的静态文件放在gh-pages分支。\n3. 每次写完文章后push到master上，Travis CI会自动编译出静态文件并部署到gh-pages分支。\n4. 因为有Travis CI帮助生成和部署，所以可以在Github上直接编辑文章了。\n5. 通过本博客左侧 build status链接可以看到每次构建的过程。\n\n### 搭建步骤📐\n\n>环境：Windows 10\n\n#### 1.本地安装Node.js，Git\n\n#### 2.在GitHub新建repository\n\n这里有两种创建方式，对应的GitHub pages地址也不一样：\n\n①仓库名为fuos.github.io（`GitHub pages`）\nHexo生成的静态博客文件需要放在master分支，博客地址为 fuos.github.io\n\n②仓库名为my-blog或者其他任意名称（`Project pages`，本博客采用这种方式）\nHexo生成的静态文件需要放在gh-pages分支，博客地址为 fuos.github.io/my-blog\n\n#### 3.安装Hexo\n\n本地安装和初始化Hexo，<folder>为任意名称，如my-blog：\n\n``` bash\n$ npm install -g hexo-cli\n$ hexo init <folder>\n$ cd <folder>\n$ npm install\n```\n\n#### 4.安装theme🎨\n\n本博客选择 indigo 作为主题，并对其中部分内容根据需要做了修改。具体安装和配置请参考官方文档：[文档 | Document](https://github.com/yscoder/hexo-theme-indigo/wiki)\n\n这里主要修改了三个地方：\n\n①page-about-me跳转地址\n\n由于我创建的仓库是第二种，所以需要对`themes/indigo/layout/page.ejs`做相应的修改（第二行为修改后）\n\n```javascript\n<a href=\"/\" class=\"avatar waves-effect waves-circle waves-light\"><%- image_tag(theme.avatar) %></a>\n<a href=\"<%- config.url %>\" class=\"avatar waves-effect waves-circle waves-light\"><%- image_tag(theme.avatar) %></a>\n```\n\n②启用gitalk评论插件\n\nowner为github account，repo为刚才创建的用于存放博客的repository，GitHub Application在 Settings -> Developer settings -> OAuth Apps申请\n\n```yaml\n# use gitalk://github.com/gitalk/gitalk\ngitalk: \n  owner: fuos\n  repo: my-blog\n  client_id: 'GitHub Application Client ID'\n  client_secret: 'GitHub Application Client Secret'\n```\n\n③优化文章永久链接\n\n进入my-blog安装插件：\n\n```bash\n$ npm install hexo-abbrlink --save\n```\n\n修改_config.yml下permalink信息：\n\n```bash\n# permalink: :year/:month/:day/:title/\n# permalink_defaults:\npermalink: posts/:abbrlink.html\n# abbrlink config\nabbrlink:\n  alg: crc32  #support crc16(default) and crc32\n  rep: hex    #support dec(default) and hex\n```\n#### 5.推送分支\n\n这里将本地博客源文件推送到了master分支\n\n```bash\ncd my-blog \ngit init \ngit remote add origin git@github.com:fuos/my-blog.git\ngit add . \ngit commit -am \"init blog\" \n# 推送到master\ngit push -u origin master\n```\n\n#### 6.使用 Travis CI 构建和部署\n\n①使用GitHub账号登陆[Travis CI](https://travis-ci.org/)，在github中创建access token，在Travis CI你的repository页面Environment Variables新建环境变量，name为GH_TOKEN，Value 为刚才你在 GitHub 生成的 Token\n\n②在my-blog下新建.travis.yml文件，添加下面的内容：\n\n```yaml\nsudo: false\nlanguage: node_js\nnode_js:\n  - 10 # use nodejs v10 LTS\ncache: npm\nbranches:\n  only:\n    - master # build master branch only\nscript:\n  - hexo generate # generate static files\ndeploy:\n  provider: pages\n  skip-cleanup: true\n  github-token: $GH_TOKEN\n  keep-history: true\n  on:\n    branch: master\n  local-dir: public\n```\n\n③修改my-blog下_config.yml中deploy部分\n\n```yaml\ndeploy:\n  type: git\n  # repo: https://github.com/<username>/<project>\n  # example, https://github.com/hexojs/hexojs.github.io\n  # Hexo静态文件默认推送到gh-pages分支\n  branch: gh-pages\n```\n\n④将修改推送到远端master\n\n```bash\ngit add .\ngit commit -m \"add travis ci\"\ngit push origin master\n```\n\n这样配置之后，Hexo已经能够自动构建和部署了，可以到travis-ci中看到[Job log](https://travis-ci.org/github/fuos/my-blog/jobs/696306109)\n\n之后写文章时可以按照下面的步骤新建和提交， Travis CI 会将Hexo生成的静态文件自动部署到gh-pages分支。\n\n```bash\ncd my-blog \ngit checkout master \nhexo new \"My First Post - Test\" \ngit add . \ngit commit -am\"add test post\" \ngit push\n```\n\n💾博客源码：https://github.com/fuos/my-blog\n\n⚙Travis CI：https://travis-ci.org/github/fuos/my-blog\n\n\n\n","slug":"GitHub Pages+Hexo+Travis CI-自动化构建的静态博客","published":1,"updated":"2020-06-14T08:49:21.817Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc9dk3bp0003nsvnbf5ih6jf","content":"<h3 id=\"博客说明📝\"><a href=\"#博客说明📝\" class=\"headerlink\" title=\"博客说明📝\"></a>博客说明📝</h3><ol>\n<li>博客托管于GitHub Pages，使用Hexo作为博客框架，使用Travis CI完成自动构建。</li>\n<li>博客源码放在master分支，编译生成的静态文件放在gh-pages分支。</li>\n<li>每次写完文章后push到master上，Travis CI会自动编译出静态文件并部署到gh-pages分支。</li>\n<li>因为有Travis CI帮助生成和部署，所以可以在Github上直接编辑文章了。</li>\n<li>通过本博客左侧 build status链接可以看到每次构建的过程。</li>\n</ol>\n<h3 id=\"搭建步骤📐\"><a href=\"#搭建步骤📐\" class=\"headerlink\" title=\"搭建步骤📐\"></a>搭建步骤📐</h3><blockquote>\n<p>环境：Windows 10</p>\n</blockquote>\n<h4 id=\"1-本地安装Node-js，Git\"><a href=\"#1-本地安装Node-js，Git\" class=\"headerlink\" title=\"1.本地安装Node.js，Git\"></a>1.本地安装Node.js，Git</h4><h4 id=\"2-在GitHub新建repository\"><a href=\"#2-在GitHub新建repository\" class=\"headerlink\" title=\"2.在GitHub新建repository\"></a>2.在GitHub新建repository</h4><p>这里有两种创建方式，对应的GitHub pages地址也不一样：</p>\n<p>①仓库名为fuos.github.io（<code>GitHub pages</code>）<br>Hexo生成的静态博客文件需要放在master分支，博客地址为 fuos.github.io</p>\n<p>②仓库名为my-blog或者其他任意名称（<code>Project pages</code>，本博客采用这种方式）<br>Hexo生成的静态文件需要放在gh-pages分支，博客地址为 fuos.github.io/my-blog</p>\n<h4 id=\"3-安装Hexo\"><a href=\"#3-安装Hexo\" class=\"headerlink\" title=\"3.安装Hexo\"></a>3.安装Hexo</h4><p>本地安装和初始化Hexo，<folder>为任意名称，如my-blog：</folder></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli</span><br><span class=\"line\">$ hexo init &lt;folder&gt;</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> &lt;folder&gt;</span><br><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-安装theme🎨\"><a href=\"#4-安装theme🎨\" class=\"headerlink\" title=\"4.安装theme🎨\"></a>4.安装theme🎨</h4><p>本博客选择 indigo 作为主题，并对其中部分内容根据需要做了修改。具体安装和配置请参考官方文档：<a href=\"https://github.com/yscoder/hexo-theme-indigo/wiki\" target=\"_blank\" rel=\"noopener\">文档 | Document</a></p>\n<p>这里主要修改了三个地方：</p>\n<p>①page-about-me跳转地址</p>\n<p>由于我创建的仓库是第二种，所以需要对<code>themes/indigo/layout/page.ejs</code>做相应的修改（第二行为修改后）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=<span class=\"string\">\"/\"</span> <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"avatar waves-effect waves-circle waves-light\"</span>&gt;&lt;%- image_tag(theme.avatar) %&gt;&lt;<span class=\"regexp\">/a&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;a href=\"&lt;%- config.url %&gt;\" class=\"avatar waves-effect waves-circle waves-light\"&gt;&lt;%- image_tag(theme.avatar) %&gt;&lt;/</span>a&gt;</span><br></pre></td></tr></table></figure>\n\n<p>②启用gitalk评论插件</p>\n<p>owner为github account，repo为刚才创建的用于存放博客的repository，GitHub Application在 Settings -&gt; Developer settings -&gt; OAuth Apps申请</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># use gitalk://github.com/gitalk/gitalk</span></span><br><span class=\"line\"><span class=\"attr\">gitalk:</span> </span><br><span class=\"line\">  <span class=\"attr\">owner:</span> <span class=\"string\">fuos</span></span><br><span class=\"line\">  <span class=\"attr\">repo:</span> <span class=\"string\">my-blog</span></span><br><span class=\"line\">  <span class=\"attr\">client_id:</span> <span class=\"string\">'GitHub Application Client ID'</span></span><br><span class=\"line\">  <span class=\"attr\">client_secret:</span> <span class=\"string\">'GitHub Application Client Secret'</span></span><br></pre></td></tr></table></figure>\n\n<p>③优化文章永久链接</p>\n<p>进入my-blog安装插件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure>\n\n<p>修改_config.yml下permalink信息：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># permalink: :year/:month/:day/:title/</span></span><br><span class=\"line\"><span class=\"comment\"># permalink_defaults:</span></span><br><span class=\"line\">permalink: posts/:abbrlink.html</span><br><span class=\"line\"><span class=\"comment\"># abbrlink config</span></span><br><span class=\"line\">abbrlink:</span><br><span class=\"line\">  alg: crc32  <span class=\"comment\">#support crc16(default) and crc32</span></span><br><span class=\"line\">  rep: hex    <span class=\"comment\">#support dec(default) and hex</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"5-推送分支\"><a href=\"#5-推送分支\" class=\"headerlink\" title=\"5.推送分支\"></a>5.推送分支</h4><p>这里将本地博客源文件推送到了master分支</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> my-blog </span><br><span class=\"line\">git init </span><br><span class=\"line\">git remote add origin git@github.com:fuos/my-blog.git</span><br><span class=\"line\">git add . </span><br><span class=\"line\">git commit -am <span class=\"string\">\"init blog\"</span> </span><br><span class=\"line\"><span class=\"comment\"># 推送到master</span></span><br><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-使用-Travis-CI-构建和部署\"><a href=\"#6-使用-Travis-CI-构建和部署\" class=\"headerlink\" title=\"6.使用 Travis CI 构建和部署\"></a>6.使用 Travis CI 构建和部署</h4><p>①使用GitHub账号登陆<a href=\"https://travis-ci.org/\" target=\"_blank\" rel=\"noopener\">Travis CI</a>，在github中创建access token，在Travis CI你的repository页面Environment Variables新建环境变量，name为GH_TOKEN，Value 为刚才你在 GitHub 生成的 Token</p>\n<p>②在my-blog下新建.travis.yml文件，添加下面的内容：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">sudo:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">language:</span> <span class=\"string\">node_js</span></span><br><span class=\"line\"><span class=\"attr\">node_js:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"number\">10</span> <span class=\"comment\"># use nodejs v10 LTS</span></span><br><span class=\"line\"><span class=\"attr\">cache:</span> <span class=\"string\">npm</span></span><br><span class=\"line\"><span class=\"attr\">branches:</span></span><br><span class=\"line\">  <span class=\"attr\">only:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">master</span> <span class=\"comment\"># build master branch only</span></span><br><span class=\"line\"><span class=\"attr\">script:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">hexo</span> <span class=\"string\">generate</span> <span class=\"comment\"># generate static files</span></span><br><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">  <span class=\"attr\">provider:</span> <span class=\"string\">pages</span></span><br><span class=\"line\">  <span class=\"attr\">skip-cleanup:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">github-token:</span> <span class=\"string\">$GH_TOKEN</span></span><br><span class=\"line\">  <span class=\"attr\">keep-history:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">on:</span></span><br><span class=\"line\">    <span class=\"attr\">branch:</span> <span class=\"string\">master</span></span><br><span class=\"line\">  <span class=\"attr\">local-dir:</span> <span class=\"string\">public</span></span><br></pre></td></tr></table></figure>\n\n<p>③修改my-blog下_config.yml中deploy部分</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">  <span class=\"comment\"># repo: https://github.com/&lt;username&gt;/&lt;project&gt;</span></span><br><span class=\"line\">  <span class=\"comment\"># example, https://github.com/hexojs/hexojs.github.io</span></span><br><span class=\"line\">  <span class=\"comment\"># Hexo静态文件默认推送到gh-pages分支</span></span><br><span class=\"line\">  <span class=\"attr\">branch:</span> <span class=\"string\">gh-pages</span></span><br></pre></td></tr></table></figure>\n\n<p>④将修改推送到远端master</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">\"add travis ci\"</span></span><br><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure>\n\n<p>这样配置之后，Hexo已经能够自动构建和部署了，可以到travis-ci中看到<a href=\"https://travis-ci.org/github/fuos/my-blog/jobs/696306109\" target=\"_blank\" rel=\"noopener\">Job log</a></p>\n<p>之后写文章时可以按照下面的步骤新建和提交， Travis CI 会将Hexo生成的静态文件自动部署到gh-pages分支。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> my-blog </span><br><span class=\"line\">git checkout master </span><br><span class=\"line\">hexo new <span class=\"string\">\"My First Post - Test\"</span> </span><br><span class=\"line\">git add . </span><br><span class=\"line\">git commit -am<span class=\"string\">\"add test post\"</span> </span><br><span class=\"line\">git push</span><br></pre></td></tr></table></figure>\n\n<p>💾博客源码：<a href=\"https://github.com/fuos/my-blog\" target=\"_blank\" rel=\"noopener\">https://github.com/fuos/my-blog</a></p>\n<p>⚙Travis CI：<a href=\"https://travis-ci.org/github/fuos/my-blog\" target=\"_blank\" rel=\"noopener\">https://travis-ci.org/github/fuos/my-blog</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"博客说明📝\"><a href=\"#博客说明📝\" class=\"headerlink\" title=\"博客说明📝\"></a>博客说明📝</h3><ol>\n<li>博客托管于GitHub Pages，使用Hexo作为博客框架，使用Travis CI完成自动构建。</li>\n<li>博客源码放在master分支，编译生成的静态文件放在gh-pages分支。</li>\n<li>每次写完文章后push到master上，Travis CI会自动编译出静态文件并部署到gh-pages分支。</li>\n<li>因为有Travis CI帮助生成和部署，所以可以在Github上直接编辑文章了。</li>\n<li>通过本博客左侧 build status链接可以看到每次构建的过程。</li>\n</ol>\n<h3 id=\"搭建步骤📐\"><a href=\"#搭建步骤📐\" class=\"headerlink\" title=\"搭建步骤📐\"></a>搭建步骤📐</h3><blockquote>\n<p>环境：Windows 10</p>\n</blockquote>\n<h4 id=\"1-本地安装Node-js，Git\"><a href=\"#1-本地安装Node-js，Git\" class=\"headerlink\" title=\"1.本地安装Node.js，Git\"></a>1.本地安装Node.js，Git</h4><h4 id=\"2-在GitHub新建repository\"><a href=\"#2-在GitHub新建repository\" class=\"headerlink\" title=\"2.在GitHub新建repository\"></a>2.在GitHub新建repository</h4><p>这里有两种创建方式，对应的GitHub pages地址也不一样：</p>\n<p>①仓库名为fuos.github.io（<code>GitHub pages</code>）<br>Hexo生成的静态博客文件需要放在master分支，博客地址为 fuos.github.io</p>\n<p>②仓库名为my-blog或者其他任意名称（<code>Project pages</code>，本博客采用这种方式）<br>Hexo生成的静态文件需要放在gh-pages分支，博客地址为 fuos.github.io/my-blog</p>\n<h4 id=\"3-安装Hexo\"><a href=\"#3-安装Hexo\" class=\"headerlink\" title=\"3.安装Hexo\"></a>3.安装Hexo</h4><p>本地安装和初始化Hexo，<folder>为任意名称，如my-blog：</folder></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli</span><br><span class=\"line\">$ hexo init &lt;folder&gt;</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> &lt;folder&gt;</span><br><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-安装theme🎨\"><a href=\"#4-安装theme🎨\" class=\"headerlink\" title=\"4.安装theme🎨\"></a>4.安装theme🎨</h4><p>本博客选择 indigo 作为主题，并对其中部分内容根据需要做了修改。具体安装和配置请参考官方文档：<a href=\"https://github.com/yscoder/hexo-theme-indigo/wiki\" target=\"_blank\" rel=\"noopener\">文档 | Document</a></p>\n<p>这里主要修改了三个地方：</p>\n<p>①page-about-me跳转地址</p>\n<p>由于我创建的仓库是第二种，所以需要对<code>themes/indigo/layout/page.ejs</code>做相应的修改（第二行为修改后）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=<span class=\"string\">\"/\"</span> <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"avatar waves-effect waves-circle waves-light\"</span>&gt;&lt;%- image_tag(theme.avatar) %&gt;&lt;<span class=\"regexp\">/a&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;a href=\"&lt;%- config.url %&gt;\" class=\"avatar waves-effect waves-circle waves-light\"&gt;&lt;%- image_tag(theme.avatar) %&gt;&lt;/</span>a&gt;</span><br></pre></td></tr></table></figure>\n\n<p>②启用gitalk评论插件</p>\n<p>owner为github account，repo为刚才创建的用于存放博客的repository，GitHub Application在 Settings -&gt; Developer settings -&gt; OAuth Apps申请</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># use gitalk://github.com/gitalk/gitalk</span></span><br><span class=\"line\"><span class=\"attr\">gitalk:</span> </span><br><span class=\"line\">  <span class=\"attr\">owner:</span> <span class=\"string\">fuos</span></span><br><span class=\"line\">  <span class=\"attr\">repo:</span> <span class=\"string\">my-blog</span></span><br><span class=\"line\">  <span class=\"attr\">client_id:</span> <span class=\"string\">'GitHub Application Client ID'</span></span><br><span class=\"line\">  <span class=\"attr\">client_secret:</span> <span class=\"string\">'GitHub Application Client Secret'</span></span><br></pre></td></tr></table></figure>\n\n<p>③优化文章永久链接</p>\n<p>进入my-blog安装插件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure>\n\n<p>修改_config.yml下permalink信息：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># permalink: :year/:month/:day/:title/</span></span><br><span class=\"line\"><span class=\"comment\"># permalink_defaults:</span></span><br><span class=\"line\">permalink: posts/:abbrlink.html</span><br><span class=\"line\"><span class=\"comment\"># abbrlink config</span></span><br><span class=\"line\">abbrlink:</span><br><span class=\"line\">  alg: crc32  <span class=\"comment\">#support crc16(default) and crc32</span></span><br><span class=\"line\">  rep: hex    <span class=\"comment\">#support dec(default) and hex</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"5-推送分支\"><a href=\"#5-推送分支\" class=\"headerlink\" title=\"5.推送分支\"></a>5.推送分支</h4><p>这里将本地博客源文件推送到了master分支</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> my-blog </span><br><span class=\"line\">git init </span><br><span class=\"line\">git remote add origin git@github.com:fuos/my-blog.git</span><br><span class=\"line\">git add . </span><br><span class=\"line\">git commit -am <span class=\"string\">\"init blog\"</span> </span><br><span class=\"line\"><span class=\"comment\"># 推送到master</span></span><br><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-使用-Travis-CI-构建和部署\"><a href=\"#6-使用-Travis-CI-构建和部署\" class=\"headerlink\" title=\"6.使用 Travis CI 构建和部署\"></a>6.使用 Travis CI 构建和部署</h4><p>①使用GitHub账号登陆<a href=\"https://travis-ci.org/\" target=\"_blank\" rel=\"noopener\">Travis CI</a>，在github中创建access token，在Travis CI你的repository页面Environment Variables新建环境变量，name为GH_TOKEN，Value 为刚才你在 GitHub 生成的 Token</p>\n<p>②在my-blog下新建.travis.yml文件，添加下面的内容：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">sudo:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">language:</span> <span class=\"string\">node_js</span></span><br><span class=\"line\"><span class=\"attr\">node_js:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"number\">10</span> <span class=\"comment\"># use nodejs v10 LTS</span></span><br><span class=\"line\"><span class=\"attr\">cache:</span> <span class=\"string\">npm</span></span><br><span class=\"line\"><span class=\"attr\">branches:</span></span><br><span class=\"line\">  <span class=\"attr\">only:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">master</span> <span class=\"comment\"># build master branch only</span></span><br><span class=\"line\"><span class=\"attr\">script:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">hexo</span> <span class=\"string\">generate</span> <span class=\"comment\"># generate static files</span></span><br><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">  <span class=\"attr\">provider:</span> <span class=\"string\">pages</span></span><br><span class=\"line\">  <span class=\"attr\">skip-cleanup:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">github-token:</span> <span class=\"string\">$GH_TOKEN</span></span><br><span class=\"line\">  <span class=\"attr\">keep-history:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">on:</span></span><br><span class=\"line\">    <span class=\"attr\">branch:</span> <span class=\"string\">master</span></span><br><span class=\"line\">  <span class=\"attr\">local-dir:</span> <span class=\"string\">public</span></span><br></pre></td></tr></table></figure>\n\n<p>③修改my-blog下_config.yml中deploy部分</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">  <span class=\"comment\"># repo: https://github.com/&lt;username&gt;/&lt;project&gt;</span></span><br><span class=\"line\">  <span class=\"comment\"># example, https://github.com/hexojs/hexojs.github.io</span></span><br><span class=\"line\">  <span class=\"comment\"># Hexo静态文件默认推送到gh-pages分支</span></span><br><span class=\"line\">  <span class=\"attr\">branch:</span> <span class=\"string\">gh-pages</span></span><br></pre></td></tr></table></figure>\n\n<p>④将修改推送到远端master</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">\"add travis ci\"</span></span><br><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure>\n\n<p>这样配置之后，Hexo已经能够自动构建和部署了，可以到travis-ci中看到<a href=\"https://travis-ci.org/github/fuos/my-blog/jobs/696306109\" target=\"_blank\" rel=\"noopener\">Job log</a></p>\n<p>之后写文章时可以按照下面的步骤新建和提交， Travis CI 会将Hexo生成的静态文件自动部署到gh-pages分支。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> my-blog </span><br><span class=\"line\">git checkout master </span><br><span class=\"line\">hexo new <span class=\"string\">\"My First Post - Test\"</span> </span><br><span class=\"line\">git add . </span><br><span class=\"line\">git commit -am<span class=\"string\">\"add test post\"</span> </span><br><span class=\"line\">git push</span><br></pre></td></tr></table></figure>\n\n<p>💾博客源码：<a href=\"https://github.com/fuos/my-blog\" target=\"_blank\" rel=\"noopener\">https://github.com/fuos/my-blog</a></p>\n<p>⚙Travis CI：<a href=\"https://travis-ci.org/github/fuos/my-blog\" target=\"_blank\" rel=\"noopener\">https://travis-ci.org/github/fuos/my-blog</a></p>\n"},{"title":"Java多线程和锁","abbrlink":"c0c98174","date":"2020-06-26T11:49:15.000Z","_content":"\n## 线程🔌\n\n一个java程序实际上是一个JVM进程。JVM进程用一个主线程来执行main()方法，在main()方法内部我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。\n\n💡多线程经常需要读写共享数据，并且需要同步。\n\n#### 多线程实现方式\n\n| extends Thread |\n\n| implements Runnable |\n\n在main()方法中，调用的run()是一个普通的java方法，不会启动新的线程。调用的start()方法是native方法，是C实现的，会启动新线程。\n\n#### 程序计数器为什么是私有的？\n\n程序计数器主要有下面两个作用：\n\n1.  字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。\n2.  在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。\n\n需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。\n\n所以，程序计数器私有主要是为了**线程切换后能恢复到正确的执行位置**\n\n#### 什么是上下文切换？\n\n当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。**任务从保存到再加载的过程就是一次上下文切换**。\n\n#### Java线程的状态有以下几种\n\n- New：新创建的线程，尚未执行；\n- Runnable：运行中的线程，正在执行`run()`方法的Java代码；\n- Blocked：运行中的线程，因为某些操作被阻塞而挂起；\n- Waiting：运行中的线程，因为某些操作在等待中；\n- Timed Waiting：运行中的线程，因为执行`sleep()`方法正在计时等待；\n- Terminated：线程已终止，因为`run()`方法执行完毕。\n\n当线程启动后，它可以在`Runnable`、`Blocked`、`Waiting`和`Timed Waiting`这几个状态之间切换，直到最后变成`Terminated`状态，线程终止。\n\n通过对另一个线程对象调用`join()`方法可以等待其执行结束。\n\n#### 中断线程的方式\n\nt.interrupt(); // 中断t线程，通过检测isInterrupted()判断是否已中断。  \nt.running = false; // 标志位置为false。\n\n#### 💡`volatile`关键字的目的是告诉虚拟机\n\n- 每次访问变量时，总是获取主内存的最新值；\n- 每次修改变量后，立刻回写到主内存。\n\n`volatile`关键字解决的是可见性问题：当一个线程修改了某个共享变量的值，其他线程能够立刻看到修改后的值。\n\n#### 守护线程\n\n- 守护线程是为其他线程服务的线程；\n- 所有非守护线程都执行完毕后，虚拟机退出；\n- 守护线程不能持有需要关闭的资源（如打开文件等）。\n\n## 锁🔒\n\n#### 可重入锁\n\nJVM允许同一个线程重复获取同一个锁，这种能被同一个线程反复获取的锁，就叫做`可重入锁`（所以需要判断是第几次锁）\n\n#### 死锁\n\n在获取多个锁的时候，不同线程获取多个不同对象的锁可能导致死锁。此时，两个线程各自持有不同的锁，然后各自试图获取对方手里的锁，造成了双方无限等待下去，这就是`死锁`。  \n死锁发生后，没有任何机制能解除死锁，只能`强制结束JVM进程`  \n怎么避免？→ 线程获取锁的顺序要一致\n\n#### ReentrantLock\n\nsynchronized可以配合wait和notify实现线程在条件不满足时等待，条件满足时唤醒，  \nReentrantLock可以配合Condition实现。\n\n- ReentrantLock获取锁更安全\n- 必须先获取到锁，再进入try {...}代码块，最后使用finally保证释放锁\n- 可以使用tryLock()尝试获取锁\n\n`Condition`提供的`await()`、`signal()`、`signalAll()`原理和 `synchronized`锁对象的`wait()`、`notify()`、`notifyAll()`是一致的，并且其行为也是一样的：\n\n- `await()`会释放当前锁，进入等待状态\n- `signal()`会唤醒某个等待线程\n- `signalAll()`会唤醒所有等待线程\n- 唤醒线程从`await()`返回后需要重新获得锁\n\n## 同步🎹\n\n`wait和notify用于多线程协调运行`\n\n- 在`synchronized`内部可以调用wait()使线程进入等待状态；\n- 必须在已获得的锁对象上调用wait()方法；\n- 在synchronized内部可以调用notify()或notifyAll()唤醒其他等待线程；\n- 必须在已获得的锁对象上调用notify()或notifyAll()方法；\n- 已唤醒的线程还需要重新获得锁后才能继续执行。\n\n## 线程池\n\n#### 常用的线程池\n\n创建这些线程池的方法都被封装到`Executors`这个类中\n\n- FixedThreadPool：线程数固定的线程池；\n- CachedThreadPool：线程数根据任务动态调整的线程池；\n- SingleThreadExecutor：仅单线程执行的线程池。\n- `ScheduledThreadPool`可以定期调度多个任务。\n\n```\n// 创建固定大小的线程池\nExecutorService executor = Executors.newFixedThreadPool(3);\n```\n\n- 线程池内部维护一组线程，可以高效执行大量小任务；\n- `Executors`提供了静态方法创建不同类型的`ExecutorService`；\n- 必须调用`shutdown()`关闭`ExecutorService`","source":"_posts/Java多线程和锁.md","raw":"---\ntitle: Java多线程和锁\ncategories: Java\ntags:\n  - Java\n  - 锁\n  - 多线程\nabbrlink: c0c98174\ndate: 2020-06-26 19:49:15\n---\n\n## 线程🔌\n\n一个java程序实际上是一个JVM进程。JVM进程用一个主线程来执行main()方法，在main()方法内部我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。\n\n💡多线程经常需要读写共享数据，并且需要同步。\n\n#### 多线程实现方式\n\n| extends Thread |\n\n| implements Runnable |\n\n在main()方法中，调用的run()是一个普通的java方法，不会启动新的线程。调用的start()方法是native方法，是C实现的，会启动新线程。\n\n#### 程序计数器为什么是私有的？\n\n程序计数器主要有下面两个作用：\n\n1.  字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。\n2.  在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。\n\n需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。\n\n所以，程序计数器私有主要是为了**线程切换后能恢复到正确的执行位置**\n\n#### 什么是上下文切换？\n\n当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。**任务从保存到再加载的过程就是一次上下文切换**。\n\n#### Java线程的状态有以下几种\n\n- New：新创建的线程，尚未执行；\n- Runnable：运行中的线程，正在执行`run()`方法的Java代码；\n- Blocked：运行中的线程，因为某些操作被阻塞而挂起；\n- Waiting：运行中的线程，因为某些操作在等待中；\n- Timed Waiting：运行中的线程，因为执行`sleep()`方法正在计时等待；\n- Terminated：线程已终止，因为`run()`方法执行完毕。\n\n当线程启动后，它可以在`Runnable`、`Blocked`、`Waiting`和`Timed Waiting`这几个状态之间切换，直到最后变成`Terminated`状态，线程终止。\n\n通过对另一个线程对象调用`join()`方法可以等待其执行结束。\n\n#### 中断线程的方式\n\nt.interrupt(); // 中断t线程，通过检测isInterrupted()判断是否已中断。  \nt.running = false; // 标志位置为false。\n\n#### 💡`volatile`关键字的目的是告诉虚拟机\n\n- 每次访问变量时，总是获取主内存的最新值；\n- 每次修改变量后，立刻回写到主内存。\n\n`volatile`关键字解决的是可见性问题：当一个线程修改了某个共享变量的值，其他线程能够立刻看到修改后的值。\n\n#### 守护线程\n\n- 守护线程是为其他线程服务的线程；\n- 所有非守护线程都执行完毕后，虚拟机退出；\n- 守护线程不能持有需要关闭的资源（如打开文件等）。\n\n## 锁🔒\n\n#### 可重入锁\n\nJVM允许同一个线程重复获取同一个锁，这种能被同一个线程反复获取的锁，就叫做`可重入锁`（所以需要判断是第几次锁）\n\n#### 死锁\n\n在获取多个锁的时候，不同线程获取多个不同对象的锁可能导致死锁。此时，两个线程各自持有不同的锁，然后各自试图获取对方手里的锁，造成了双方无限等待下去，这就是`死锁`。  \n死锁发生后，没有任何机制能解除死锁，只能`强制结束JVM进程`  \n怎么避免？→ 线程获取锁的顺序要一致\n\n#### ReentrantLock\n\nsynchronized可以配合wait和notify实现线程在条件不满足时等待，条件满足时唤醒，  \nReentrantLock可以配合Condition实现。\n\n- ReentrantLock获取锁更安全\n- 必须先获取到锁，再进入try {...}代码块，最后使用finally保证释放锁\n- 可以使用tryLock()尝试获取锁\n\n`Condition`提供的`await()`、`signal()`、`signalAll()`原理和 `synchronized`锁对象的`wait()`、`notify()`、`notifyAll()`是一致的，并且其行为也是一样的：\n\n- `await()`会释放当前锁，进入等待状态\n- `signal()`会唤醒某个等待线程\n- `signalAll()`会唤醒所有等待线程\n- 唤醒线程从`await()`返回后需要重新获得锁\n\n## 同步🎹\n\n`wait和notify用于多线程协调运行`\n\n- 在`synchronized`内部可以调用wait()使线程进入等待状态；\n- 必须在已获得的锁对象上调用wait()方法；\n- 在synchronized内部可以调用notify()或notifyAll()唤醒其他等待线程；\n- 必须在已获得的锁对象上调用notify()或notifyAll()方法；\n- 已唤醒的线程还需要重新获得锁后才能继续执行。\n\n## 线程池\n\n#### 常用的线程池\n\n创建这些线程池的方法都被封装到`Executors`这个类中\n\n- FixedThreadPool：线程数固定的线程池；\n- CachedThreadPool：线程数根据任务动态调整的线程池；\n- SingleThreadExecutor：仅单线程执行的线程池。\n- `ScheduledThreadPool`可以定期调度多个任务。\n\n```\n// 创建固定大小的线程池\nExecutorService executor = Executors.newFixedThreadPool(3);\n```\n\n- 线程池内部维护一组线程，可以高效执行大量小任务；\n- `Executors`提供了静态方法创建不同类型的`ExecutorService`；\n- 必须调用`shutdown()`关闭`ExecutorService`","slug":"Java多线程和锁","published":1,"updated":"2020-07-05T12:12:04.289Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc9dk3by0006nsvn6djh52ho","content":"<h2 id=\"线程🔌\"><a href=\"#线程🔌\" class=\"headerlink\" title=\"线程🔌\"></a>线程🔌</h2><p>一个java程序实际上是一个JVM进程。JVM进程用一个主线程来执行main()方法，在main()方法内部我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。</p>\n<p>💡多线程经常需要读写共享数据，并且需要同步。</p>\n<h4 id=\"多线程实现方式\"><a href=\"#多线程实现方式\" class=\"headerlink\" title=\"多线程实现方式\"></a>多线程实现方式</h4><p>| extends Thread |</p>\n<p>| implements Runnable |</p>\n<p>在main()方法中，调用的run()是一个普通的java方法，不会启动新的线程。调用的start()方法是native方法，是C实现的，会启动新线程。</p>\n<h4 id=\"程序计数器为什么是私有的？\"><a href=\"#程序计数器为什么是私有的？\" class=\"headerlink\" title=\"程序计数器为什么是私有的？\"></a>程序计数器为什么是私有的？</h4><p>程序计数器主要有下面两个作用：</p>\n<ol>\n<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>\n<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>\n</ol>\n<p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p>\n<p>所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong></p>\n<h4 id=\"什么是上下文切换？\"><a href=\"#什么是上下文切换？\" class=\"headerlink\" title=\"什么是上下文切换？\"></a>什么是上下文切换？</h4><p>当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>\n<h4 id=\"Java线程的状态有以下几种\"><a href=\"#Java线程的状态有以下几种\" class=\"headerlink\" title=\"Java线程的状态有以下几种\"></a>Java线程的状态有以下几种</h4><ul>\n<li>New：新创建的线程，尚未执行；</li>\n<li>Runnable：运行中的线程，正在执行<code>run()</code>方法的Java代码；</li>\n<li>Blocked：运行中的线程，因为某些操作被阻塞而挂起；</li>\n<li>Waiting：运行中的线程，因为某些操作在等待中；</li>\n<li>Timed Waiting：运行中的线程，因为执行<code>sleep()</code>方法正在计时等待；</li>\n<li>Terminated：线程已终止，因为<code>run()</code>方法执行完毕。</li>\n</ul>\n<p>当线程启动后，它可以在<code>Runnable</code>、<code>Blocked</code>、<code>Waiting</code>和<code>Timed Waiting</code>这几个状态之间切换，直到最后变成<code>Terminated</code>状态，线程终止。</p>\n<p>通过对另一个线程对象调用<code>join()</code>方法可以等待其执行结束。</p>\n<h4 id=\"中断线程的方式\"><a href=\"#中断线程的方式\" class=\"headerlink\" title=\"中断线程的方式\"></a>中断线程的方式</h4><p>t.interrupt(); // 中断t线程，通过检测isInterrupted()判断是否已中断。<br>t.running = false; // 标志位置为false。</p>\n<h4 id=\"💡volatile关键字的目的是告诉虚拟机\"><a href=\"#💡volatile关键字的目的是告诉虚拟机\" class=\"headerlink\" title=\"💡volatile关键字的目的是告诉虚拟机\"></a>💡<code>volatile</code>关键字的目的是告诉虚拟机</h4><ul>\n<li>每次访问变量时，总是获取主内存的最新值；</li>\n<li>每次修改变量后，立刻回写到主内存。</li>\n</ul>\n<p><code>volatile</code>关键字解决的是可见性问题：当一个线程修改了某个共享变量的值，其他线程能够立刻看到修改后的值。</p>\n<h4 id=\"守护线程\"><a href=\"#守护线程\" class=\"headerlink\" title=\"守护线程\"></a>守护线程</h4><ul>\n<li>守护线程是为其他线程服务的线程；</li>\n<li>所有非守护线程都执行完毕后，虚拟机退出；</li>\n<li>守护线程不能持有需要关闭的资源（如打开文件等）。</li>\n</ul>\n<h2 id=\"锁🔒\"><a href=\"#锁🔒\" class=\"headerlink\" title=\"锁🔒\"></a>锁🔒</h2><h4 id=\"可重入锁\"><a href=\"#可重入锁\" class=\"headerlink\" title=\"可重入锁\"></a>可重入锁</h4><p>JVM允许同一个线程重复获取同一个锁，这种能被同一个线程反复获取的锁，就叫做<code>可重入锁</code>（所以需要判断是第几次锁）</p>\n<h4 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h4><p>在获取多个锁的时候，不同线程获取多个不同对象的锁可能导致死锁。此时，两个线程各自持有不同的锁，然后各自试图获取对方手里的锁，造成了双方无限等待下去，这就是<code>死锁</code>。<br>死锁发生后，没有任何机制能解除死锁，只能<code>强制结束JVM进程</code><br>怎么避免？→ 线程获取锁的顺序要一致</p>\n<h4 id=\"ReentrantLock\"><a href=\"#ReentrantLock\" class=\"headerlink\" title=\"ReentrantLock\"></a>ReentrantLock</h4><p>synchronized可以配合wait和notify实现线程在条件不满足时等待，条件满足时唤醒，<br>ReentrantLock可以配合Condition实现。</p>\n<ul>\n<li>ReentrantLock获取锁更安全</li>\n<li>必须先获取到锁，再进入try {…}代码块，最后使用finally保证释放锁</li>\n<li>可以使用tryLock()尝试获取锁</li>\n</ul>\n<p><code>Condition</code>提供的<code>await()</code>、<code>signal()</code>、<code>signalAll()</code>原理和 <code>synchronized</code>锁对象的<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>是一致的，并且其行为也是一样的：</p>\n<ul>\n<li><code>await()</code>会释放当前锁，进入等待状态</li>\n<li><code>signal()</code>会唤醒某个等待线程</li>\n<li><code>signalAll()</code>会唤醒所有等待线程</li>\n<li>唤醒线程从<code>await()</code>返回后需要重新获得锁</li>\n</ul>\n<h2 id=\"同步🎹\"><a href=\"#同步🎹\" class=\"headerlink\" title=\"同步🎹\"></a>同步🎹</h2><p><code>wait和notify用于多线程协调运行</code></p>\n<ul>\n<li>在<code>synchronized</code>内部可以调用wait()使线程进入等待状态；</li>\n<li>必须在已获得的锁对象上调用wait()方法；</li>\n<li>在synchronized内部可以调用notify()或notifyAll()唤醒其他等待线程；</li>\n<li>必须在已获得的锁对象上调用notify()或notifyAll()方法；</li>\n<li>已唤醒的线程还需要重新获得锁后才能继续执行。</li>\n</ul>\n<h2 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h2><h4 id=\"常用的线程池\"><a href=\"#常用的线程池\" class=\"headerlink\" title=\"常用的线程池\"></a>常用的线程池</h4><p>创建这些线程池的方法都被封装到<code>Executors</code>这个类中</p>\n<ul>\n<li>FixedThreadPool：线程数固定的线程池；</li>\n<li>CachedThreadPool：线程数根据任务动态调整的线程池；</li>\n<li>SingleThreadExecutor：仅单线程执行的线程池。</li>\n<li><code>ScheduledThreadPool</code>可以定期调度多个任务。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 创建固定大小的线程池</span><br><span class=\"line\">ExecutorService executor &#x3D; Executors.newFixedThreadPool(3);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>线程池内部维护一组线程，可以高效执行大量小任务；</li>\n<li><code>Executors</code>提供了静态方法创建不同类型的<code>ExecutorService</code>；</li>\n<li>必须调用<code>shutdown()</code>关闭<code>ExecutorService</code></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"线程🔌\"><a href=\"#线程🔌\" class=\"headerlink\" title=\"线程🔌\"></a>线程🔌</h2><p>一个java程序实际上是一个JVM进程。JVM进程用一个主线程来执行main()方法，在main()方法内部我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。</p>\n<p>💡多线程经常需要读写共享数据，并且需要同步。</p>\n<h4 id=\"多线程实现方式\"><a href=\"#多线程实现方式\" class=\"headerlink\" title=\"多线程实现方式\"></a>多线程实现方式</h4><p>| extends Thread |</p>\n<p>| implements Runnable |</p>\n<p>在main()方法中，调用的run()是一个普通的java方法，不会启动新的线程。调用的start()方法是native方法，是C实现的，会启动新线程。</p>\n<h4 id=\"程序计数器为什么是私有的？\"><a href=\"#程序计数器为什么是私有的？\" class=\"headerlink\" title=\"程序计数器为什么是私有的？\"></a>程序计数器为什么是私有的？</h4><p>程序计数器主要有下面两个作用：</p>\n<ol>\n<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>\n<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>\n</ol>\n<p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p>\n<p>所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong></p>\n<h4 id=\"什么是上下文切换？\"><a href=\"#什么是上下文切换？\" class=\"headerlink\" title=\"什么是上下文切换？\"></a>什么是上下文切换？</h4><p>当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>\n<h4 id=\"Java线程的状态有以下几种\"><a href=\"#Java线程的状态有以下几种\" class=\"headerlink\" title=\"Java线程的状态有以下几种\"></a>Java线程的状态有以下几种</h4><ul>\n<li>New：新创建的线程，尚未执行；</li>\n<li>Runnable：运行中的线程，正在执行<code>run()</code>方法的Java代码；</li>\n<li>Blocked：运行中的线程，因为某些操作被阻塞而挂起；</li>\n<li>Waiting：运行中的线程，因为某些操作在等待中；</li>\n<li>Timed Waiting：运行中的线程，因为执行<code>sleep()</code>方法正在计时等待；</li>\n<li>Terminated：线程已终止，因为<code>run()</code>方法执行完毕。</li>\n</ul>\n<p>当线程启动后，它可以在<code>Runnable</code>、<code>Blocked</code>、<code>Waiting</code>和<code>Timed Waiting</code>这几个状态之间切换，直到最后变成<code>Terminated</code>状态，线程终止。</p>\n<p>通过对另一个线程对象调用<code>join()</code>方法可以等待其执行结束。</p>\n<h4 id=\"中断线程的方式\"><a href=\"#中断线程的方式\" class=\"headerlink\" title=\"中断线程的方式\"></a>中断线程的方式</h4><p>t.interrupt(); // 中断t线程，通过检测isInterrupted()判断是否已中断。<br>t.running = false; // 标志位置为false。</p>\n<h4 id=\"💡volatile关键字的目的是告诉虚拟机\"><a href=\"#💡volatile关键字的目的是告诉虚拟机\" class=\"headerlink\" title=\"💡volatile关键字的目的是告诉虚拟机\"></a>💡<code>volatile</code>关键字的目的是告诉虚拟机</h4><ul>\n<li>每次访问变量时，总是获取主内存的最新值；</li>\n<li>每次修改变量后，立刻回写到主内存。</li>\n</ul>\n<p><code>volatile</code>关键字解决的是可见性问题：当一个线程修改了某个共享变量的值，其他线程能够立刻看到修改后的值。</p>\n<h4 id=\"守护线程\"><a href=\"#守护线程\" class=\"headerlink\" title=\"守护线程\"></a>守护线程</h4><ul>\n<li>守护线程是为其他线程服务的线程；</li>\n<li>所有非守护线程都执行完毕后，虚拟机退出；</li>\n<li>守护线程不能持有需要关闭的资源（如打开文件等）。</li>\n</ul>\n<h2 id=\"锁🔒\"><a href=\"#锁🔒\" class=\"headerlink\" title=\"锁🔒\"></a>锁🔒</h2><h4 id=\"可重入锁\"><a href=\"#可重入锁\" class=\"headerlink\" title=\"可重入锁\"></a>可重入锁</h4><p>JVM允许同一个线程重复获取同一个锁，这种能被同一个线程反复获取的锁，就叫做<code>可重入锁</code>（所以需要判断是第几次锁）</p>\n<h4 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h4><p>在获取多个锁的时候，不同线程获取多个不同对象的锁可能导致死锁。此时，两个线程各自持有不同的锁，然后各自试图获取对方手里的锁，造成了双方无限等待下去，这就是<code>死锁</code>。<br>死锁发生后，没有任何机制能解除死锁，只能<code>强制结束JVM进程</code><br>怎么避免？→ 线程获取锁的顺序要一致</p>\n<h4 id=\"ReentrantLock\"><a href=\"#ReentrantLock\" class=\"headerlink\" title=\"ReentrantLock\"></a>ReentrantLock</h4><p>synchronized可以配合wait和notify实现线程在条件不满足时等待，条件满足时唤醒，<br>ReentrantLock可以配合Condition实现。</p>\n<ul>\n<li>ReentrantLock获取锁更安全</li>\n<li>必须先获取到锁，再进入try {…}代码块，最后使用finally保证释放锁</li>\n<li>可以使用tryLock()尝试获取锁</li>\n</ul>\n<p><code>Condition</code>提供的<code>await()</code>、<code>signal()</code>、<code>signalAll()</code>原理和 <code>synchronized</code>锁对象的<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>是一致的，并且其行为也是一样的：</p>\n<ul>\n<li><code>await()</code>会释放当前锁，进入等待状态</li>\n<li><code>signal()</code>会唤醒某个等待线程</li>\n<li><code>signalAll()</code>会唤醒所有等待线程</li>\n<li>唤醒线程从<code>await()</code>返回后需要重新获得锁</li>\n</ul>\n<h2 id=\"同步🎹\"><a href=\"#同步🎹\" class=\"headerlink\" title=\"同步🎹\"></a>同步🎹</h2><p><code>wait和notify用于多线程协调运行</code></p>\n<ul>\n<li>在<code>synchronized</code>内部可以调用wait()使线程进入等待状态；</li>\n<li>必须在已获得的锁对象上调用wait()方法；</li>\n<li>在synchronized内部可以调用notify()或notifyAll()唤醒其他等待线程；</li>\n<li>必须在已获得的锁对象上调用notify()或notifyAll()方法；</li>\n<li>已唤醒的线程还需要重新获得锁后才能继续执行。</li>\n</ul>\n<h2 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h2><h4 id=\"常用的线程池\"><a href=\"#常用的线程池\" class=\"headerlink\" title=\"常用的线程池\"></a>常用的线程池</h4><p>创建这些线程池的方法都被封装到<code>Executors</code>这个类中</p>\n<ul>\n<li>FixedThreadPool：线程数固定的线程池；</li>\n<li>CachedThreadPool：线程数根据任务动态调整的线程池；</li>\n<li>SingleThreadExecutor：仅单线程执行的线程池。</li>\n<li><code>ScheduledThreadPool</code>可以定期调度多个任务。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 创建固定大小的线程池</span><br><span class=\"line\">ExecutorService executor &#x3D; Executors.newFixedThreadPool(3);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>线程池内部维护一组线程，可以高效执行大量小任务；</li>\n<li><code>Executors</code>提供了静态方法创建不同类型的<code>ExecutorService</code>；</li>\n<li>必须调用<code>shutdown()</code>关闭<code>ExecutorService</code></li>\n</ul>\n"},{"title":"Hive DDL ROW FORMAT","abbrlink":"acf44460","date":"2020-06-17T05:38:22.000Z","_content":"\n### DDL语法规则\n\n- CREATE DATABASE/SCHEMA, TABLE, VIEW, FUNCTION, INDEX（创建 数据库/模式，表，视图，函数，索引）\n- DROP DATABASE/SCHEMA, TABLE, VIEW, INDEX（删除 数据库/模式，表，视图，索引）\n- TRUNCATE TABLE（清空 表）\n- ALTER DATABASE/SCHEMA, TABLE, VIEW（修改 数据库/模式，表，视图）\n- MSCK REPAIR TABLE (or ALTER TABLE RECOVER PARTITIONS)（MSCK修复表或ALTER TABLE恢复分区）\n- SHOW DATABASES/SCHEMAS, TABLES, TBLPROPERTIES, VIEWS, PARTITIONS, FUNCTIONS, INDEX[ES], COLUMNS, CREATE TABLE（查看）\n- DESCRIBE DATABASE/SCHEMA, table_name, view_name（查看 数据库/模式描述信息）\n\n创建表时需要指定数据切分格式，会用到ROW FORMAT关键字。可以参考Hive官网关于ROW FORMAT的用法。\n\n下面通过一个例子说明数据之间分隔符用法。比如有两条数据：\n\n```\n1,Lilei,book-tv-code,beijing:chaoyang-shanghai:pudong\n2,Hanmeimei,book-Lilei-code,beijing:haidian-shanghai:huangpu\n```\n\n先看JAVA集合框架图，明确每个字段数据类型，再看数据格式，指定分隔符。\n\n### 分隔符类型\n\n限定符开始语句----------ROW FORMAT DELIMITED\n\n每个字段之间由[ , ]分割----------FIELDS TERMINATED BY ','\n\n第二个字段是Array形式，元素与元素之间由[ - ]分割----------COLLECTION ITEMS TERMINATED BY '-'\n\n第三个字段是K-V形式，每组K-V对内部由[ : ]分割，每组K-V对之间由[ - ]分割----------MAP KEYS TERMINATED BY ':'\n\n每条数据之间由换行符分割（默认[ \\n ]），如果是其它分割方式（比如[ ; ]）----------LINES TERMINATED BY ';'\n\n### 完整建表语句\n\n```sql\ncreate table psn (\nid INT,\nname STRING,\nhobbies ARRAY <STRING>,\naddress MAP <STRING, STRING>\n)\nROW FORMAT DELIMITED\nFIELDS TERMINATED BY ','\nCOLLECTION ITEMS TERMINATED BY '-'\nMAP KEYS TERMINATED BY ':'; \n```\n\n","source":"_posts/Hive-DDL-ROW-FORMAT.md","raw":"---\ntitle: Hive DDL ROW FORMAT\ncategories: 大数据\ntags: Hive\nabbrlink: acf44460\ndate: 2020-06-17 13:38:22\n---\n\n### DDL语法规则\n\n- CREATE DATABASE/SCHEMA, TABLE, VIEW, FUNCTION, INDEX（创建 数据库/模式，表，视图，函数，索引）\n- DROP DATABASE/SCHEMA, TABLE, VIEW, INDEX（删除 数据库/模式，表，视图，索引）\n- TRUNCATE TABLE（清空 表）\n- ALTER DATABASE/SCHEMA, TABLE, VIEW（修改 数据库/模式，表，视图）\n- MSCK REPAIR TABLE (or ALTER TABLE RECOVER PARTITIONS)（MSCK修复表或ALTER TABLE恢复分区）\n- SHOW DATABASES/SCHEMAS, TABLES, TBLPROPERTIES, VIEWS, PARTITIONS, FUNCTIONS, INDEX[ES], COLUMNS, CREATE TABLE（查看）\n- DESCRIBE DATABASE/SCHEMA, table_name, view_name（查看 数据库/模式描述信息）\n\n创建表时需要指定数据切分格式，会用到ROW FORMAT关键字。可以参考Hive官网关于ROW FORMAT的用法。\n\n下面通过一个例子说明数据之间分隔符用法。比如有两条数据：\n\n```\n1,Lilei,book-tv-code,beijing:chaoyang-shanghai:pudong\n2,Hanmeimei,book-Lilei-code,beijing:haidian-shanghai:huangpu\n```\n\n先看JAVA集合框架图，明确每个字段数据类型，再看数据格式，指定分隔符。\n\n### 分隔符类型\n\n限定符开始语句----------ROW FORMAT DELIMITED\n\n每个字段之间由[ , ]分割----------FIELDS TERMINATED BY ','\n\n第二个字段是Array形式，元素与元素之间由[ - ]分割----------COLLECTION ITEMS TERMINATED BY '-'\n\n第三个字段是K-V形式，每组K-V对内部由[ : ]分割，每组K-V对之间由[ - ]分割----------MAP KEYS TERMINATED BY ':'\n\n每条数据之间由换行符分割（默认[ \\n ]），如果是其它分割方式（比如[ ; ]）----------LINES TERMINATED BY ';'\n\n### 完整建表语句\n\n```sql\ncreate table psn (\nid INT,\nname STRING,\nhobbies ARRAY <STRING>,\naddress MAP <STRING, STRING>\n)\nROW FORMAT DELIMITED\nFIELDS TERMINATED BY ','\nCOLLECTION ITEMS TERMINATED BY '-'\nMAP KEYS TERMINATED BY ':'; \n```\n\n","slug":"Hive-DDL-ROW-FORMAT","published":1,"updated":"2020-07-05T12:12:04.292Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc9dk3c10007nsvn85q19wa0","content":"<h3 id=\"DDL语法规则\"><a href=\"#DDL语法规则\" class=\"headerlink\" title=\"DDL语法规则\"></a>DDL语法规则</h3><ul>\n<li>CREATE DATABASE/SCHEMA, TABLE, VIEW, FUNCTION, INDEX（创建 数据库/模式，表，视图，函数，索引）</li>\n<li>DROP DATABASE/SCHEMA, TABLE, VIEW, INDEX（删除 数据库/模式，表，视图，索引）</li>\n<li>TRUNCATE TABLE（清空 表）</li>\n<li>ALTER DATABASE/SCHEMA, TABLE, VIEW（修改 数据库/模式，表，视图）</li>\n<li>MSCK REPAIR TABLE (or ALTER TABLE RECOVER PARTITIONS)（MSCK修复表或ALTER TABLE恢复分区）</li>\n<li>SHOW DATABASES/SCHEMAS, TABLES, TBLPROPERTIES, VIEWS, PARTITIONS, FUNCTIONS, INDEX[ES], COLUMNS, CREATE TABLE（查看）</li>\n<li>DESCRIBE DATABASE/SCHEMA, table_name, view_name（查看 数据库/模式描述信息）</li>\n</ul>\n<p>创建表时需要指定数据切分格式，会用到ROW FORMAT关键字。可以参考Hive官网关于ROW FORMAT的用法。</p>\n<p>下面通过一个例子说明数据之间分隔符用法。比如有两条数据：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1,Lilei,book-tv-code,beijing:chaoyang-shanghai:pudong</span><br><span class=\"line\">2,Hanmeimei,book-Lilei-code,beijing:haidian-shanghai:huangpu</span><br></pre></td></tr></table></figure>\n\n<p>先看JAVA集合框架图，明确每个字段数据类型，再看数据格式，指定分隔符。</p>\n<h3 id=\"分隔符类型\"><a href=\"#分隔符类型\" class=\"headerlink\" title=\"分隔符类型\"></a>分隔符类型</h3><p>限定符开始语句———-ROW FORMAT DELIMITED</p>\n<p>每个字段之间由[ , ]分割———-FIELDS TERMINATED BY ‘,’</p>\n<p>第二个字段是Array形式，元素与元素之间由[ - ]分割———-COLLECTION ITEMS TERMINATED BY ‘-‘</p>\n<p>第三个字段是K-V形式，每组K-V对内部由[ : ]分割，每组K-V对之间由[ - ]分割———-MAP KEYS TERMINATED BY ‘:’</p>\n<p>每条数据之间由换行符分割（默认[ \\n ]），如果是其它分割方式（比如[ ; ]）———-LINES TERMINATED BY ‘;’</p>\n<h3 id=\"完整建表语句\"><a href=\"#完整建表语句\" class=\"headerlink\" title=\"完整建表语句\"></a>完整建表语句</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> psn (</span><br><span class=\"line\"><span class=\"keyword\">id</span> <span class=\"built_in\">INT</span>,</span><br><span class=\"line\"><span class=\"keyword\">name</span> <span class=\"keyword\">STRING</span>,</span><br><span class=\"line\">hobbies <span class=\"built_in\">ARRAY</span> &lt;<span class=\"keyword\">STRING</span>&gt;,</span><br><span class=\"line\">address <span class=\"keyword\">MAP</span> &lt;<span class=\"keyword\">STRING</span>, <span class=\"keyword\">STRING</span>&gt;</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">ROW</span> <span class=\"keyword\">FORMAT</span> <span class=\"keyword\">DELIMITED</span></span><br><span class=\"line\"><span class=\"keyword\">FIELDS</span> <span class=\"keyword\">TERMINATED</span> <span class=\"keyword\">BY</span> <span class=\"string\">','</span></span><br><span class=\"line\">COLLECTION ITEMS <span class=\"keyword\">TERMINATED</span> <span class=\"keyword\">BY</span> <span class=\"string\">'-'</span></span><br><span class=\"line\"><span class=\"keyword\">MAP</span> <span class=\"keyword\">KEYS</span> <span class=\"keyword\">TERMINATED</span> <span class=\"keyword\">BY</span> <span class=\"string\">':'</span>;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"DDL语法规则\"><a href=\"#DDL语法规则\" class=\"headerlink\" title=\"DDL语法规则\"></a>DDL语法规则</h3><ul>\n<li>CREATE DATABASE/SCHEMA, TABLE, VIEW, FUNCTION, INDEX（创建 数据库/模式，表，视图，函数，索引）</li>\n<li>DROP DATABASE/SCHEMA, TABLE, VIEW, INDEX（删除 数据库/模式，表，视图，索引）</li>\n<li>TRUNCATE TABLE（清空 表）</li>\n<li>ALTER DATABASE/SCHEMA, TABLE, VIEW（修改 数据库/模式，表，视图）</li>\n<li>MSCK REPAIR TABLE (or ALTER TABLE RECOVER PARTITIONS)（MSCK修复表或ALTER TABLE恢复分区）</li>\n<li>SHOW DATABASES/SCHEMAS, TABLES, TBLPROPERTIES, VIEWS, PARTITIONS, FUNCTIONS, INDEX[ES], COLUMNS, CREATE TABLE（查看）</li>\n<li>DESCRIBE DATABASE/SCHEMA, table_name, view_name（查看 数据库/模式描述信息）</li>\n</ul>\n<p>创建表时需要指定数据切分格式，会用到ROW FORMAT关键字。可以参考Hive官网关于ROW FORMAT的用法。</p>\n<p>下面通过一个例子说明数据之间分隔符用法。比如有两条数据：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1,Lilei,book-tv-code,beijing:chaoyang-shanghai:pudong</span><br><span class=\"line\">2,Hanmeimei,book-Lilei-code,beijing:haidian-shanghai:huangpu</span><br></pre></td></tr></table></figure>\n\n<p>先看JAVA集合框架图，明确每个字段数据类型，再看数据格式，指定分隔符。</p>\n<h3 id=\"分隔符类型\"><a href=\"#分隔符类型\" class=\"headerlink\" title=\"分隔符类型\"></a>分隔符类型</h3><p>限定符开始语句———-ROW FORMAT DELIMITED</p>\n<p>每个字段之间由[ , ]分割———-FIELDS TERMINATED BY ‘,’</p>\n<p>第二个字段是Array形式，元素与元素之间由[ - ]分割———-COLLECTION ITEMS TERMINATED BY ‘-‘</p>\n<p>第三个字段是K-V形式，每组K-V对内部由[ : ]分割，每组K-V对之间由[ - ]分割———-MAP KEYS TERMINATED BY ‘:’</p>\n<p>每条数据之间由换行符分割（默认[ \\n ]），如果是其它分割方式（比如[ ; ]）———-LINES TERMINATED BY ‘;’</p>\n<h3 id=\"完整建表语句\"><a href=\"#完整建表语句\" class=\"headerlink\" title=\"完整建表语句\"></a>完整建表语句</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> psn (</span><br><span class=\"line\"><span class=\"keyword\">id</span> <span class=\"built_in\">INT</span>,</span><br><span class=\"line\"><span class=\"keyword\">name</span> <span class=\"keyword\">STRING</span>,</span><br><span class=\"line\">hobbies <span class=\"built_in\">ARRAY</span> &lt;<span class=\"keyword\">STRING</span>&gt;,</span><br><span class=\"line\">address <span class=\"keyword\">MAP</span> &lt;<span class=\"keyword\">STRING</span>, <span class=\"keyword\">STRING</span>&gt;</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">ROW</span> <span class=\"keyword\">FORMAT</span> <span class=\"keyword\">DELIMITED</span></span><br><span class=\"line\"><span class=\"keyword\">FIELDS</span> <span class=\"keyword\">TERMINATED</span> <span class=\"keyword\">BY</span> <span class=\"string\">','</span></span><br><span class=\"line\">COLLECTION ITEMS <span class=\"keyword\">TERMINATED</span> <span class=\"keyword\">BY</span> <span class=\"string\">'-'</span></span><br><span class=\"line\"><span class=\"keyword\">MAP</span> <span class=\"keyword\">KEYS</span> <span class=\"keyword\">TERMINATED</span> <span class=\"keyword\">BY</span> <span class=\"string\">':'</span>;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"My First Post - Test","toc":true,"abbrlink":"667634fc","date":"2020-06-07T11:10:45.000Z","_content":"\n## 测试，推送第一篇文章。 \n\n### Markdown 是什么？\n\nMarkdown 是一种轻量级的「标记语言」，创始人为约翰·格鲁伯，用简洁的语法代替排版，目前被越来越多的知识工作者、写作爱好者、程序员或研究员广泛使用。其常用的标记符号不超过十个，相对于更为复杂的 HTML 标记语言来说，Markdown 十分的轻量，学习成本也不需要太多，且一旦熟悉这种语法规则，会有沉浸式编辑的效果。\n\n### 印象笔记里 Markdown 有什么特点？\n\n#### 插入表格\n\n| 帐户类型 | 免费帐户 | 标准帐户 | 高级帐户 |\n| --- | --- | --- | --- |\n| 帐户流量 | 60M | 1GB | 10GB |\n| 设备数目 | 2台 | 无限制 | 无限制 |\n| 当前价格 | 免费 | ￥8.17/月 | ￥12.33/月|\n\n#### 插入行内代码或代码块\n\n```python\n@requires_authorization\nclass SomeClass:\n    pass\n\nif __name__ == '__main__':\n    # A comment\n    print 'hello world'\n```\n\n#### 添加待办事项\n\n三只青蛙\n* [x] 第一只青蛙\n* [ ] 第二只青蛙\n* [ ] 第三只青蛙\n\n#### 插入链接\n\ncopy from [印象笔记官网](https://www.yinxiang.com/)\n\n\n","source":"_posts/My-First-Post-Test.md","raw":"---\ntitle: My First Post - Test\ntoc: true\ntags: Hexo\nabbrlink: 667634fc\ndate: 2020-06-07 19:10:45\n---\n\n## 测试，推送第一篇文章。 \n\n### Markdown 是什么？\n\nMarkdown 是一种轻量级的「标记语言」，创始人为约翰·格鲁伯，用简洁的语法代替排版，目前被越来越多的知识工作者、写作爱好者、程序员或研究员广泛使用。其常用的标记符号不超过十个，相对于更为复杂的 HTML 标记语言来说，Markdown 十分的轻量，学习成本也不需要太多，且一旦熟悉这种语法规则，会有沉浸式编辑的效果。\n\n### 印象笔记里 Markdown 有什么特点？\n\n#### 插入表格\n\n| 帐户类型 | 免费帐户 | 标准帐户 | 高级帐户 |\n| --- | --- | --- | --- |\n| 帐户流量 | 60M | 1GB | 10GB |\n| 设备数目 | 2台 | 无限制 | 无限制 |\n| 当前价格 | 免费 | ￥8.17/月 | ￥12.33/月|\n\n#### 插入行内代码或代码块\n\n```python\n@requires_authorization\nclass SomeClass:\n    pass\n\nif __name__ == '__main__':\n    # A comment\n    print 'hello world'\n```\n\n#### 添加待办事项\n\n三只青蛙\n* [x] 第一只青蛙\n* [ ] 第二只青蛙\n* [ ] 第三只青蛙\n\n#### 插入链接\n\ncopy from [印象笔记官网](https://www.yinxiang.com/)\n\n\n","slug":"My-First-Post-Test","published":1,"updated":"2020-06-09T13:44:48.634Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc9dk3c40008nsvn87av8umz","content":"<h2 id=\"测试，推送第一篇文章。\"><a href=\"#测试，推送第一篇文章。\" class=\"headerlink\" title=\"测试，推送第一篇文章。\"></a>测试，推送第一篇文章。</h2><h3 id=\"Markdown-是什么？\"><a href=\"#Markdown-是什么？\" class=\"headerlink\" title=\"Markdown 是什么？\"></a>Markdown 是什么？</h3><p>Markdown 是一种轻量级的「标记语言」，创始人为约翰·格鲁伯，用简洁的语法代替排版，目前被越来越多的知识工作者、写作爱好者、程序员或研究员广泛使用。其常用的标记符号不超过十个，相对于更为复杂的 HTML 标记语言来说，Markdown 十分的轻量，学习成本也不需要太多，且一旦熟悉这种语法规则，会有沉浸式编辑的效果。</p>\n<h3 id=\"印象笔记里-Markdown-有什么特点？\"><a href=\"#印象笔记里-Markdown-有什么特点？\" class=\"headerlink\" title=\"印象笔记里 Markdown 有什么特点？\"></a>印象笔记里 Markdown 有什么特点？</h3><h4 id=\"插入表格\"><a href=\"#插入表格\" class=\"headerlink\" title=\"插入表格\"></a>插入表格</h4><table>\n<thead>\n<tr>\n<th>帐户类型</th>\n<th>免费帐户</th>\n<th>标准帐户</th>\n<th>高级帐户</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>帐户流量</td>\n<td>60M</td>\n<td>1GB</td>\n<td>10GB</td>\n</tr>\n<tr>\n<td>设备数目</td>\n<td>2台</td>\n<td>无限制</td>\n<td>无限制</td>\n</tr>\n<tr>\n<td>当前价格</td>\n<td>免费</td>\n<td>￥8.17/月</td>\n<td>￥12.33/月</td>\n</tr>\n</tbody></table>\n<h4 id=\"插入行内代码或代码块\"><a href=\"#插入行内代码或代码块\" class=\"headerlink\" title=\"插入行内代码或代码块\"></a>插入行内代码或代码块</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@requires_authorization</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeClass</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    <span class=\"comment\"># A comment</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'hello world'</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"添加待办事项\"><a href=\"#添加待办事项\" class=\"headerlink\" title=\"添加待办事项\"></a>添加待办事项</h4><p>三只青蛙</p>\n<ul>\n<li><input checked disabled type=\"checkbox\"> 第一只青蛙</li>\n<li><input disabled type=\"checkbox\"> 第二只青蛙</li>\n<li><input disabled type=\"checkbox\"> 第三只青蛙</li>\n</ul>\n<h4 id=\"插入链接\"><a href=\"#插入链接\" class=\"headerlink\" title=\"插入链接\"></a>插入链接</h4><p>copy from <a href=\"https://www.yinxiang.com/\" target=\"_blank\" rel=\"noopener\">印象笔记官网</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"测试，推送第一篇文章。\"><a href=\"#测试，推送第一篇文章。\" class=\"headerlink\" title=\"测试，推送第一篇文章。\"></a>测试，推送第一篇文章。</h2><h3 id=\"Markdown-是什么？\"><a href=\"#Markdown-是什么？\" class=\"headerlink\" title=\"Markdown 是什么？\"></a>Markdown 是什么？</h3><p>Markdown 是一种轻量级的「标记语言」，创始人为约翰·格鲁伯，用简洁的语法代替排版，目前被越来越多的知识工作者、写作爱好者、程序员或研究员广泛使用。其常用的标记符号不超过十个，相对于更为复杂的 HTML 标记语言来说，Markdown 十分的轻量，学习成本也不需要太多，且一旦熟悉这种语法规则，会有沉浸式编辑的效果。</p>\n<h3 id=\"印象笔记里-Markdown-有什么特点？\"><a href=\"#印象笔记里-Markdown-有什么特点？\" class=\"headerlink\" title=\"印象笔记里 Markdown 有什么特点？\"></a>印象笔记里 Markdown 有什么特点？</h3><h4 id=\"插入表格\"><a href=\"#插入表格\" class=\"headerlink\" title=\"插入表格\"></a>插入表格</h4><table>\n<thead>\n<tr>\n<th>帐户类型</th>\n<th>免费帐户</th>\n<th>标准帐户</th>\n<th>高级帐户</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>帐户流量</td>\n<td>60M</td>\n<td>1GB</td>\n<td>10GB</td>\n</tr>\n<tr>\n<td>设备数目</td>\n<td>2台</td>\n<td>无限制</td>\n<td>无限制</td>\n</tr>\n<tr>\n<td>当前价格</td>\n<td>免费</td>\n<td>￥8.17/月</td>\n<td>￥12.33/月</td>\n</tr>\n</tbody></table>\n<h4 id=\"插入行内代码或代码块\"><a href=\"#插入行内代码或代码块\" class=\"headerlink\" title=\"插入行内代码或代码块\"></a>插入行内代码或代码块</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@requires_authorization</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeClass</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    <span class=\"comment\"># A comment</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'hello world'</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"添加待办事项\"><a href=\"#添加待办事项\" class=\"headerlink\" title=\"添加待办事项\"></a>添加待办事项</h4><p>三只青蛙</p>\n<ul>\n<li><input checked disabled type=\"checkbox\"> 第一只青蛙</li>\n<li><input disabled type=\"checkbox\"> 第二只青蛙</li>\n<li><input disabled type=\"checkbox\"> 第三只青蛙</li>\n</ul>\n<h4 id=\"插入链接\"><a href=\"#插入链接\" class=\"headerlink\" title=\"插入链接\"></a>插入链接</h4><p>copy from <a href=\"https://www.yinxiang.com/\" target=\"_blank\" rel=\"noopener\">印象笔记官网</a></p>\n"},{"title":"PAI算法组件详解-PLDA","abbrlink":"72ac77ba","date":"2020-06-17T05:15:12.000Z","_content":"\n### 通过文章主题做文本分类的理论依据\n\n直观来讲，如果一篇文章有一个中心思想，那么一些特定词语会更频繁的出现。比方说，如果一篇文章是在讲猫的，那\"猫\"和\"鱼\"等词出现的频率会高些，如果一篇文章是在讲狗的，那\"狗\"和\"骨头\"等词出现的频率会高些。而有些词例如\"这个\"、\"和\"大概在两篇文章中出现的频率会大致相等。但真实的情况是，一篇文章通常包含多种主题，而且每个主题所占比例各不相同。因此，如果一篇文章10%和猫有关，90%和狗有关，那么和狗相关的关键字出现的次数大概会是和猫相关的关键字出现次数的9倍。\n\n- 由于上面的理论基础，在文本分析中就有了基于文章主题的分类方法。\n\n主题模型是用来在一系列文档中发现抽象主题（topic）的一种统计模型（在机器学习PAI平台，我们给PLDA组件设置topic参数值为50，表示让每篇文章抽象出50个主题）。\n\n### 主题模型核心思想：数学框架（统计+概率）\n\n主题模型试图用数学框架来体现文档的这种特点。主题模型自动分析每个文档，统计文档内的词语，根据统计的信息来断定当前文档含有哪些主题，以及每个主题所占的比例各为多少。\n\n#### 下面说一种最经典的主题模型-LDA（隐含狄利克雷分布）\n\nLDA(Latent Dirichlet allocation)，是一种主题模型，它可以将[文档集]中每篇文档的主题按照概率分布的形式给出，从而通过分析一些文档抽取出它们的主题，然后根据主题给文本分类。它是一种无监督学习算法，在训练时不需要手工标注的训练集，需要的仅仅是文档集以及指定主题的数量k（这个K就是PLDA参数topic）即可。\n\n#### 目前机器学习PAI平台文本分析组件PLDA，它是Google对LDA的开源实现。\n\n### 语料生成过程（语料就是我们需要分析的所有文本，即文本集）\n\n假设语料库中有M篇文档（在这里我们定义：z是主题, w是词, d是文档），其中W(m)表示第m篇文档中的词，Z(m)表示这些词对应的topic编号。所有的word和对应的topic如下表示：\n\n红色方框内即表示一篇文档是由若干个词组成的，每个词都对应一个主题。（就像一篇文章所有的词都是为了更好的表达主题而存在的）\n\n### 下面我们思考当写一篇文章时你是怎么做的。\n\n假设你要写一篇文章，首先想好了主题（一个或多个），然后围绕这几个主题（比如\"Arts\"\"Budgets\"\"Children\"\"Education\"）你会想到很多与之相关的词：\n\n最后我们就是用这些和主题相关的词完成了一篇文章，就像下图一样，不同的颜色代表不同主题下的词，从颜色能看出每个主题的下面的词出现概率是不相同的：\n\n上面的这个案例是我们在确定主题和词之后生成文章的步骤。然后伟大的数学家把这个过程抽象成了概率分布问题（关于如何抽象，当然是一大堆假设和公式推导，最后得出结论）\n\n生成这篇文章可以看作如下过程：\n\n首先以一定的概率在\"Arts\"、\"Budgets\"、\"Children\"、\"Education\"中选择一个主题\n\n然后再以一定的概率在这个主题下选择某个单词\n\n不断重复以上两个步骤，最终完成一篇文章\n\n这里的两次\"以一定的概率\"，后面会有解释。\n\n### 通过上面的分析，我们知道了文章生成过程，下来来说LDA模型\n\n《LDA数学八卦》中把文档生成过程抽象成了一个游戏，主要是为了解决刚才我们说的\"以一定概率\"的问题。上帝有两种类型骰子：\n\n上面红框里面内容是说，每个doc-topic骰子是一篇文章的所有主题。\n\n上帝在LDA模型中，玩文档生成游戏的规则是这样的：\n\n这个文档生成规则可以看作如下过程：\n\n#### 首先上帝有两大坛骰子\n\n第一坛装的是doc-topic骰子，就是和所有文档相关的所有主题；\n\n第二坛装的是topic-word骰子，就是和所有主题相关的所有单词；\n\n#### 开始文档生成游戏\n\n随机从topic-word坛子独立抽取K个骰子，编号为1，2，3…k\n\n随机从doc-topic坛子抽取一个骰子，然后重复如下过程生成文档中的词:\n\n投掷doc-topic骰子，得到一个topic编号z\n\n投掷刚才K个骰子中选择编号为z的那个骰子，得到一个词\n\n每次都是先生成一篇文档之后再生成第二篇，文档中每个词的生成都要投掷两次骰子，第一次投掷doc-topic骰子得到一个topic，第二次投掷topic-word骰子得到一个word，就是说生成文档中的一个词要投掷2次。如果语料中有N个词，那么上帝要抛2N次，轮换抛doc-topic和topic-word。实际上一些投掷顺序是可以交换的（这里有很多公式推导，最终得到这个顺序可以交换），我们可以等价交换这2N次投掷顺序，先抛N次doc-topic骰子，得到语料中所有词的topic，然后基于每个topic的编号，再抛N次topic-word骰子得到语料中所有word。\n\n于是上帝的游戏规则就变成了这样：\n\n这个过程是这样的：\n\n随机从topic-word坛子独立抽取K个骰子，编号为1，2，3…k\n\n随机抽取一个doc-topic骰子，然后抛出得到一个主题z，再次抽取doc-topic骰子，再抛出，得到一个主题z（注意：由于是再次抽取，所以不一定还是之前那篇文档的主题）；重复这个步骤就能得到语料中所有文档主题\n\n从头到尾抛我们抽到的doc-topic骰子，从最开始抽到的topic-word骰子中取相应编号（在1到k中拿）的骰子抛出，得到对应的word\n\n以面的过程是先生成了语料中所有的topic，然后生成了所有的word。在topic生成的情况下word顺序是可以交换的，即如果确定了topic k，就算和它相关的word不在同一篇文章中，也是可以交换的。\n\n...数学家们做了假设和分析，搞懂了原理，他们决定把这些用公式表示,于是就算啊算，用到了贝叶斯、Dirichlet-Multionmial共轭结构、Gibbs-Sampling采样（一堆公式）最终...\n\n**牛X的数学家（神）得到了一个公式：**\n\n这里面z，i，k，t，v，m...只要知道都是一系列参数就行，比如文档编号、topic编号、word编号、第k个topic产生的词中word t的个数、文章数量...\n\n这个公式右边就是p(topic|word)*p(word|topic)，概率就是doc-->topic-->word的路径概率：\n\n接下来任务有两个：\n\n这里用到了Gibbs-Sampling公式，它的意义就是在k条路径中采样，基于语料训练LDA模型，模型中参数可以基于采集到的样本进行评估（我们做这些都是为了得到上面式子的参数）。\n\n下面是训练过程：\n\n由这个topic-word频率矩阵我们可以计算出每一个p(word|topic)概率。\n\nGibbs-Sampling收敛后统计每篇文档中topic的频率分布就可以计算出p(topic|doc)的概率。(PAI平台PLDA组件有六个输出桩后面会解释)\n\nLDA的核心公式如下：\n\nP(word|doc)=p(word|topic)*p(topic|doc)\n\n**通过计算可以得到任意一个topic对应文档d中单词w出现的概率，通过这个概率不断修正我们的参数。**\n\n- 有了模型，接下来做的就是对于新来的文档doc(new)计算topic语义分布。\n\n下面是具体计算过程：\n\n迭代过程即：首先产生一个均匀分布的随机数，然后根据上式计算每个转移主题的概率，通过累积概率判断随机数落在哪个new topic下，更新参数矩阵，如此迭代直至收敛。\n\n###\t回到我们机器学习PAI，先看下PLDA模块的6个输出桩\n\n1. 输出桩1：词频，算法内部抽样后每个词在主题出现次数\n2. 输出桩2：P(单词|主题)每个主题下词的概率\n3. 输出桩3：P(主题|单词)每个单词对应各个主题的概率\n4. 输出桩4：P(文档|主题)每个主题对应各个文档的概率\n5. 输出桩5：P(主题|文档)每个文档对应主题的概率\n6. 输出桩6：P(主题)每个主题的概率，表明在整个文档中的权重\n\n通过上面的公式推导，计算出关键的几个概率，通过贝叶斯公式这几个值都是可以算出来的。\n\n第5个是输出桩输出结果显示的是每篇文章对应的每个主题的概率，而这个概率在上面通过p(topic|doc)已经算出。\n\n在实验中我们设置参数topic=50，这个主题数是相对**整个语料库**而言的，我们最后看到的结果是这50个主题在每一篇文章上的分布情况。其它默认即可。对于默认的几个参数给予功能性的说明：\n\n我们将文章id列和主题概率分布列，得到每个主题在每篇文章的概率分布如下图所示：\n\n上面把文章从主题的维度表示成了一个向量。接下来就可以通过向量的距离实现聚类，从而实现文章分类。\n\n备注：图片丢失，原文链接在评论中。","source":"_posts/PAI算法组件详解-PLDA.md","raw":"---\ntitle: PAI算法组件详解-PLDA\ncategories: 算法\ntags: PLDA\nabbrlink: 72ac77ba\ndate: 2020-06-17 13:15:12\n---\n\n### 通过文章主题做文本分类的理论依据\n\n直观来讲，如果一篇文章有一个中心思想，那么一些特定词语会更频繁的出现。比方说，如果一篇文章是在讲猫的，那\"猫\"和\"鱼\"等词出现的频率会高些，如果一篇文章是在讲狗的，那\"狗\"和\"骨头\"等词出现的频率会高些。而有些词例如\"这个\"、\"和\"大概在两篇文章中出现的频率会大致相等。但真实的情况是，一篇文章通常包含多种主题，而且每个主题所占比例各不相同。因此，如果一篇文章10%和猫有关，90%和狗有关，那么和狗相关的关键字出现的次数大概会是和猫相关的关键字出现次数的9倍。\n\n- 由于上面的理论基础，在文本分析中就有了基于文章主题的分类方法。\n\n主题模型是用来在一系列文档中发现抽象主题（topic）的一种统计模型（在机器学习PAI平台，我们给PLDA组件设置topic参数值为50，表示让每篇文章抽象出50个主题）。\n\n### 主题模型核心思想：数学框架（统计+概率）\n\n主题模型试图用数学框架来体现文档的这种特点。主题模型自动分析每个文档，统计文档内的词语，根据统计的信息来断定当前文档含有哪些主题，以及每个主题所占的比例各为多少。\n\n#### 下面说一种最经典的主题模型-LDA（隐含狄利克雷分布）\n\nLDA(Latent Dirichlet allocation)，是一种主题模型，它可以将[文档集]中每篇文档的主题按照概率分布的形式给出，从而通过分析一些文档抽取出它们的主题，然后根据主题给文本分类。它是一种无监督学习算法，在训练时不需要手工标注的训练集，需要的仅仅是文档集以及指定主题的数量k（这个K就是PLDA参数topic）即可。\n\n#### 目前机器学习PAI平台文本分析组件PLDA，它是Google对LDA的开源实现。\n\n### 语料生成过程（语料就是我们需要分析的所有文本，即文本集）\n\n假设语料库中有M篇文档（在这里我们定义：z是主题, w是词, d是文档），其中W(m)表示第m篇文档中的词，Z(m)表示这些词对应的topic编号。所有的word和对应的topic如下表示：\n\n红色方框内即表示一篇文档是由若干个词组成的，每个词都对应一个主题。（就像一篇文章所有的词都是为了更好的表达主题而存在的）\n\n### 下面我们思考当写一篇文章时你是怎么做的。\n\n假设你要写一篇文章，首先想好了主题（一个或多个），然后围绕这几个主题（比如\"Arts\"\"Budgets\"\"Children\"\"Education\"）你会想到很多与之相关的词：\n\n最后我们就是用这些和主题相关的词完成了一篇文章，就像下图一样，不同的颜色代表不同主题下的词，从颜色能看出每个主题的下面的词出现概率是不相同的：\n\n上面的这个案例是我们在确定主题和词之后生成文章的步骤。然后伟大的数学家把这个过程抽象成了概率分布问题（关于如何抽象，当然是一大堆假设和公式推导，最后得出结论）\n\n生成这篇文章可以看作如下过程：\n\n首先以一定的概率在\"Arts\"、\"Budgets\"、\"Children\"、\"Education\"中选择一个主题\n\n然后再以一定的概率在这个主题下选择某个单词\n\n不断重复以上两个步骤，最终完成一篇文章\n\n这里的两次\"以一定的概率\"，后面会有解释。\n\n### 通过上面的分析，我们知道了文章生成过程，下来来说LDA模型\n\n《LDA数学八卦》中把文档生成过程抽象成了一个游戏，主要是为了解决刚才我们说的\"以一定概率\"的问题。上帝有两种类型骰子：\n\n上面红框里面内容是说，每个doc-topic骰子是一篇文章的所有主题。\n\n上帝在LDA模型中，玩文档生成游戏的规则是这样的：\n\n这个文档生成规则可以看作如下过程：\n\n#### 首先上帝有两大坛骰子\n\n第一坛装的是doc-topic骰子，就是和所有文档相关的所有主题；\n\n第二坛装的是topic-word骰子，就是和所有主题相关的所有单词；\n\n#### 开始文档生成游戏\n\n随机从topic-word坛子独立抽取K个骰子，编号为1，2，3…k\n\n随机从doc-topic坛子抽取一个骰子，然后重复如下过程生成文档中的词:\n\n投掷doc-topic骰子，得到一个topic编号z\n\n投掷刚才K个骰子中选择编号为z的那个骰子，得到一个词\n\n每次都是先生成一篇文档之后再生成第二篇，文档中每个词的生成都要投掷两次骰子，第一次投掷doc-topic骰子得到一个topic，第二次投掷topic-word骰子得到一个word，就是说生成文档中的一个词要投掷2次。如果语料中有N个词，那么上帝要抛2N次，轮换抛doc-topic和topic-word。实际上一些投掷顺序是可以交换的（这里有很多公式推导，最终得到这个顺序可以交换），我们可以等价交换这2N次投掷顺序，先抛N次doc-topic骰子，得到语料中所有词的topic，然后基于每个topic的编号，再抛N次topic-word骰子得到语料中所有word。\n\n于是上帝的游戏规则就变成了这样：\n\n这个过程是这样的：\n\n随机从topic-word坛子独立抽取K个骰子，编号为1，2，3…k\n\n随机抽取一个doc-topic骰子，然后抛出得到一个主题z，再次抽取doc-topic骰子，再抛出，得到一个主题z（注意：由于是再次抽取，所以不一定还是之前那篇文档的主题）；重复这个步骤就能得到语料中所有文档主题\n\n从头到尾抛我们抽到的doc-topic骰子，从最开始抽到的topic-word骰子中取相应编号（在1到k中拿）的骰子抛出，得到对应的word\n\n以面的过程是先生成了语料中所有的topic，然后生成了所有的word。在topic生成的情况下word顺序是可以交换的，即如果确定了topic k，就算和它相关的word不在同一篇文章中，也是可以交换的。\n\n...数学家们做了假设和分析，搞懂了原理，他们决定把这些用公式表示,于是就算啊算，用到了贝叶斯、Dirichlet-Multionmial共轭结构、Gibbs-Sampling采样（一堆公式）最终...\n\n**牛X的数学家（神）得到了一个公式：**\n\n这里面z，i，k，t，v，m...只要知道都是一系列参数就行，比如文档编号、topic编号、word编号、第k个topic产生的词中word t的个数、文章数量...\n\n这个公式右边就是p(topic|word)*p(word|topic)，概率就是doc-->topic-->word的路径概率：\n\n接下来任务有两个：\n\n这里用到了Gibbs-Sampling公式，它的意义就是在k条路径中采样，基于语料训练LDA模型，模型中参数可以基于采集到的样本进行评估（我们做这些都是为了得到上面式子的参数）。\n\n下面是训练过程：\n\n由这个topic-word频率矩阵我们可以计算出每一个p(word|topic)概率。\n\nGibbs-Sampling收敛后统计每篇文档中topic的频率分布就可以计算出p(topic|doc)的概率。(PAI平台PLDA组件有六个输出桩后面会解释)\n\nLDA的核心公式如下：\n\nP(word|doc)=p(word|topic)*p(topic|doc)\n\n**通过计算可以得到任意一个topic对应文档d中单词w出现的概率，通过这个概率不断修正我们的参数。**\n\n- 有了模型，接下来做的就是对于新来的文档doc(new)计算topic语义分布。\n\n下面是具体计算过程：\n\n迭代过程即：首先产生一个均匀分布的随机数，然后根据上式计算每个转移主题的概率，通过累积概率判断随机数落在哪个new topic下，更新参数矩阵，如此迭代直至收敛。\n\n###\t回到我们机器学习PAI，先看下PLDA模块的6个输出桩\n\n1. 输出桩1：词频，算法内部抽样后每个词在主题出现次数\n2. 输出桩2：P(单词|主题)每个主题下词的概率\n3. 输出桩3：P(主题|单词)每个单词对应各个主题的概率\n4. 输出桩4：P(文档|主题)每个主题对应各个文档的概率\n5. 输出桩5：P(主题|文档)每个文档对应主题的概率\n6. 输出桩6：P(主题)每个主题的概率，表明在整个文档中的权重\n\n通过上面的公式推导，计算出关键的几个概率，通过贝叶斯公式这几个值都是可以算出来的。\n\n第5个是输出桩输出结果显示的是每篇文章对应的每个主题的概率，而这个概率在上面通过p(topic|doc)已经算出。\n\n在实验中我们设置参数topic=50，这个主题数是相对**整个语料库**而言的，我们最后看到的结果是这50个主题在每一篇文章上的分布情况。其它默认即可。对于默认的几个参数给予功能性的说明：\n\n我们将文章id列和主题概率分布列，得到每个主题在每篇文章的概率分布如下图所示：\n\n上面把文章从主题的维度表示成了一个向量。接下来就可以通过向量的距离实现聚类，从而实现文章分类。\n\n备注：图片丢失，原文链接在评论中。","slug":"PAI算法组件详解-PLDA","published":1,"updated":"2020-07-05T12:12:04.316Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc9dk3c8000cnsvnbi6zec6n","content":"<h3 id=\"通过文章主题做文本分类的理论依据\"><a href=\"#通过文章主题做文本分类的理论依据\" class=\"headerlink\" title=\"通过文章主题做文本分类的理论依据\"></a>通过文章主题做文本分类的理论依据</h3><p>直观来讲，如果一篇文章有一个中心思想，那么一些特定词语会更频繁的出现。比方说，如果一篇文章是在讲猫的，那”猫”和”鱼”等词出现的频率会高些，如果一篇文章是在讲狗的，那”狗”和”骨头”等词出现的频率会高些。而有些词例如”这个”、”和”大概在两篇文章中出现的频率会大致相等。但真实的情况是，一篇文章通常包含多种主题，而且每个主题所占比例各不相同。因此，如果一篇文章10%和猫有关，90%和狗有关，那么和狗相关的关键字出现的次数大概会是和猫相关的关键字出现次数的9倍。</p>\n<ul>\n<li>由于上面的理论基础，在文本分析中就有了基于文章主题的分类方法。</li>\n</ul>\n<p>主题模型是用来在一系列文档中发现抽象主题（topic）的一种统计模型（在机器学习PAI平台，我们给PLDA组件设置topic参数值为50，表示让每篇文章抽象出50个主题）。</p>\n<h3 id=\"主题模型核心思想：数学框架（统计-概率）\"><a href=\"#主题模型核心思想：数学框架（统计-概率）\" class=\"headerlink\" title=\"主题模型核心思想：数学框架（统计+概率）\"></a>主题模型核心思想：数学框架（统计+概率）</h3><p>主题模型试图用数学框架来体现文档的这种特点。主题模型自动分析每个文档，统计文档内的词语，根据统计的信息来断定当前文档含有哪些主题，以及每个主题所占的比例各为多少。</p>\n<h4 id=\"下面说一种最经典的主题模型-LDA（隐含狄利克雷分布）\"><a href=\"#下面说一种最经典的主题模型-LDA（隐含狄利克雷分布）\" class=\"headerlink\" title=\"下面说一种最经典的主题模型-LDA（隐含狄利克雷分布）\"></a>下面说一种最经典的主题模型-LDA（隐含狄利克雷分布）</h4><p>LDA(Latent Dirichlet allocation)，是一种主题模型，它可以将[文档集]中每篇文档的主题按照概率分布的形式给出，从而通过分析一些文档抽取出它们的主题，然后根据主题给文本分类。它是一种无监督学习算法，在训练时不需要手工标注的训练集，需要的仅仅是文档集以及指定主题的数量k（这个K就是PLDA参数topic）即可。</p>\n<h4 id=\"目前机器学习PAI平台文本分析组件PLDA，它是Google对LDA的开源实现。\"><a href=\"#目前机器学习PAI平台文本分析组件PLDA，它是Google对LDA的开源实现。\" class=\"headerlink\" title=\"目前机器学习PAI平台文本分析组件PLDA，它是Google对LDA的开源实现。\"></a>目前机器学习PAI平台文本分析组件PLDA，它是Google对LDA的开源实现。</h4><h3 id=\"语料生成过程（语料就是我们需要分析的所有文本，即文本集）\"><a href=\"#语料生成过程（语料就是我们需要分析的所有文本，即文本集）\" class=\"headerlink\" title=\"语料生成过程（语料就是我们需要分析的所有文本，即文本集）\"></a>语料生成过程（语料就是我们需要分析的所有文本，即文本集）</h3><p>假设语料库中有M篇文档（在这里我们定义：z是主题, w是词, d是文档），其中W(m)表示第m篇文档中的词，Z(m)表示这些词对应的topic编号。所有的word和对应的topic如下表示：</p>\n<p>红色方框内即表示一篇文档是由若干个词组成的，每个词都对应一个主题。（就像一篇文章所有的词都是为了更好的表达主题而存在的）</p>\n<h3 id=\"下面我们思考当写一篇文章时你是怎么做的。\"><a href=\"#下面我们思考当写一篇文章时你是怎么做的。\" class=\"headerlink\" title=\"下面我们思考当写一篇文章时你是怎么做的。\"></a>下面我们思考当写一篇文章时你是怎么做的。</h3><p>假设你要写一篇文章，首先想好了主题（一个或多个），然后围绕这几个主题（比如”Arts””Budgets””Children””Education”）你会想到很多与之相关的词：</p>\n<p>最后我们就是用这些和主题相关的词完成了一篇文章，就像下图一样，不同的颜色代表不同主题下的词，从颜色能看出每个主题的下面的词出现概率是不相同的：</p>\n<p>上面的这个案例是我们在确定主题和词之后生成文章的步骤。然后伟大的数学家把这个过程抽象成了概率分布问题（关于如何抽象，当然是一大堆假设和公式推导，最后得出结论）</p>\n<p>生成这篇文章可以看作如下过程：</p>\n<p>首先以一定的概率在”Arts”、”Budgets”、”Children”、”Education”中选择一个主题</p>\n<p>然后再以一定的概率在这个主题下选择某个单词</p>\n<p>不断重复以上两个步骤，最终完成一篇文章</p>\n<p>这里的两次”以一定的概率”，后面会有解释。</p>\n<h3 id=\"通过上面的分析，我们知道了文章生成过程，下来来说LDA模型\"><a href=\"#通过上面的分析，我们知道了文章生成过程，下来来说LDA模型\" class=\"headerlink\" title=\"通过上面的分析，我们知道了文章生成过程，下来来说LDA模型\"></a>通过上面的分析，我们知道了文章生成过程，下来来说LDA模型</h3><p>《LDA数学八卦》中把文档生成过程抽象成了一个游戏，主要是为了解决刚才我们说的”以一定概率”的问题。上帝有两种类型骰子：</p>\n<p>上面红框里面内容是说，每个doc-topic骰子是一篇文章的所有主题。</p>\n<p>上帝在LDA模型中，玩文档生成游戏的规则是这样的：</p>\n<p>这个文档生成规则可以看作如下过程：</p>\n<h4 id=\"首先上帝有两大坛骰子\"><a href=\"#首先上帝有两大坛骰子\" class=\"headerlink\" title=\"首先上帝有两大坛骰子\"></a>首先上帝有两大坛骰子</h4><p>第一坛装的是doc-topic骰子，就是和所有文档相关的所有主题；</p>\n<p>第二坛装的是topic-word骰子，就是和所有主题相关的所有单词；</p>\n<h4 id=\"开始文档生成游戏\"><a href=\"#开始文档生成游戏\" class=\"headerlink\" title=\"开始文档生成游戏\"></a>开始文档生成游戏</h4><p>随机从topic-word坛子独立抽取K个骰子，编号为1，2，3…k</p>\n<p>随机从doc-topic坛子抽取一个骰子，然后重复如下过程生成文档中的词:</p>\n<p>投掷doc-topic骰子，得到一个topic编号z</p>\n<p>投掷刚才K个骰子中选择编号为z的那个骰子，得到一个词</p>\n<p>每次都是先生成一篇文档之后再生成第二篇，文档中每个词的生成都要投掷两次骰子，第一次投掷doc-topic骰子得到一个topic，第二次投掷topic-word骰子得到一个word，就是说生成文档中的一个词要投掷2次。如果语料中有N个词，那么上帝要抛2N次，轮换抛doc-topic和topic-word。实际上一些投掷顺序是可以交换的（这里有很多公式推导，最终得到这个顺序可以交换），我们可以等价交换这2N次投掷顺序，先抛N次doc-topic骰子，得到语料中所有词的topic，然后基于每个topic的编号，再抛N次topic-word骰子得到语料中所有word。</p>\n<p>于是上帝的游戏规则就变成了这样：</p>\n<p>这个过程是这样的：</p>\n<p>随机从topic-word坛子独立抽取K个骰子，编号为1，2，3…k</p>\n<p>随机抽取一个doc-topic骰子，然后抛出得到一个主题z，再次抽取doc-topic骰子，再抛出，得到一个主题z（注意：由于是再次抽取，所以不一定还是之前那篇文档的主题）；重复这个步骤就能得到语料中所有文档主题</p>\n<p>从头到尾抛我们抽到的doc-topic骰子，从最开始抽到的topic-word骰子中取相应编号（在1到k中拿）的骰子抛出，得到对应的word</p>\n<p>以面的过程是先生成了语料中所有的topic，然后生成了所有的word。在topic生成的情况下word顺序是可以交换的，即如果确定了topic k，就算和它相关的word不在同一篇文章中，也是可以交换的。</p>\n<p>…数学家们做了假设和分析，搞懂了原理，他们决定把这些用公式表示,于是就算啊算，用到了贝叶斯、Dirichlet-Multionmial共轭结构、Gibbs-Sampling采样（一堆公式）最终…</p>\n<p><strong>牛X的数学家（神）得到了一个公式：</strong></p>\n<p>这里面z，i，k，t，v，m…只要知道都是一系列参数就行，比如文档编号、topic编号、word编号、第k个topic产生的词中word t的个数、文章数量…</p>\n<p>这个公式右边就是p(topic|word)*p(word|topic)，概率就是doc–&gt;topic–&gt;word的路径概率：</p>\n<p>接下来任务有两个：</p>\n<p>这里用到了Gibbs-Sampling公式，它的意义就是在k条路径中采样，基于语料训练LDA模型，模型中参数可以基于采集到的样本进行评估（我们做这些都是为了得到上面式子的参数）。</p>\n<p>下面是训练过程：</p>\n<p>由这个topic-word频率矩阵我们可以计算出每一个p(word|topic)概率。</p>\n<p>Gibbs-Sampling收敛后统计每篇文档中topic的频率分布就可以计算出p(topic|doc)的概率。(PAI平台PLDA组件有六个输出桩后面会解释)</p>\n<p>LDA的核心公式如下：</p>\n<p>P(word|doc)=p(word|topic)*p(topic|doc)</p>\n<p><strong>通过计算可以得到任意一个topic对应文档d中单词w出现的概率，通过这个概率不断修正我们的参数。</strong></p>\n<ul>\n<li>有了模型，接下来做的就是对于新来的文档doc(new)计算topic语义分布。</li>\n</ul>\n<p>下面是具体计算过程：</p>\n<p>迭代过程即：首先产生一个均匀分布的随机数，然后根据上式计算每个转移主题的概率，通过累积概率判断随机数落在哪个new topic下，更新参数矩阵，如此迭代直至收敛。</p>\n<h3 id=\"回到我们机器学习PAI，先看下PLDA模块的6个输出桩\"><a href=\"#回到我们机器学习PAI，先看下PLDA模块的6个输出桩\" class=\"headerlink\" title=\"回到我们机器学习PAI，先看下PLDA模块的6个输出桩\"></a>回到我们机器学习PAI，先看下PLDA模块的6个输出桩</h3><ol>\n<li>输出桩1：词频，算法内部抽样后每个词在主题出现次数</li>\n<li>输出桩2：P(单词|主题)每个主题下词的概率</li>\n<li>输出桩3：P(主题|单词)每个单词对应各个主题的概率</li>\n<li>输出桩4：P(文档|主题)每个主题对应各个文档的概率</li>\n<li>输出桩5：P(主题|文档)每个文档对应主题的概率</li>\n<li>输出桩6：P(主题)每个主题的概率，表明在整个文档中的权重</li>\n</ol>\n<p>通过上面的公式推导，计算出关键的几个概率，通过贝叶斯公式这几个值都是可以算出来的。</p>\n<p>第5个是输出桩输出结果显示的是每篇文章对应的每个主题的概率，而这个概率在上面通过p(topic|doc)已经算出。</p>\n<p>在实验中我们设置参数topic=50，这个主题数是相对<strong>整个语料库</strong>而言的，我们最后看到的结果是这50个主题在每一篇文章上的分布情况。其它默认即可。对于默认的几个参数给予功能性的说明：</p>\n<p>我们将文章id列和主题概率分布列，得到每个主题在每篇文章的概率分布如下图所示：</p>\n<p>上面把文章从主题的维度表示成了一个向量。接下来就可以通过向量的距离实现聚类，从而实现文章分类。</p>\n<p>备注：图片丢失，原文链接在评论中。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"通过文章主题做文本分类的理论依据\"><a href=\"#通过文章主题做文本分类的理论依据\" class=\"headerlink\" title=\"通过文章主题做文本分类的理论依据\"></a>通过文章主题做文本分类的理论依据</h3><p>直观来讲，如果一篇文章有一个中心思想，那么一些特定词语会更频繁的出现。比方说，如果一篇文章是在讲猫的，那”猫”和”鱼”等词出现的频率会高些，如果一篇文章是在讲狗的，那”狗”和”骨头”等词出现的频率会高些。而有些词例如”这个”、”和”大概在两篇文章中出现的频率会大致相等。但真实的情况是，一篇文章通常包含多种主题，而且每个主题所占比例各不相同。因此，如果一篇文章10%和猫有关，90%和狗有关，那么和狗相关的关键字出现的次数大概会是和猫相关的关键字出现次数的9倍。</p>\n<ul>\n<li>由于上面的理论基础，在文本分析中就有了基于文章主题的分类方法。</li>\n</ul>\n<p>主题模型是用来在一系列文档中发现抽象主题（topic）的一种统计模型（在机器学习PAI平台，我们给PLDA组件设置topic参数值为50，表示让每篇文章抽象出50个主题）。</p>\n<h3 id=\"主题模型核心思想：数学框架（统计-概率）\"><a href=\"#主题模型核心思想：数学框架（统计-概率）\" class=\"headerlink\" title=\"主题模型核心思想：数学框架（统计+概率）\"></a>主题模型核心思想：数学框架（统计+概率）</h3><p>主题模型试图用数学框架来体现文档的这种特点。主题模型自动分析每个文档，统计文档内的词语，根据统计的信息来断定当前文档含有哪些主题，以及每个主题所占的比例各为多少。</p>\n<h4 id=\"下面说一种最经典的主题模型-LDA（隐含狄利克雷分布）\"><a href=\"#下面说一种最经典的主题模型-LDA（隐含狄利克雷分布）\" class=\"headerlink\" title=\"下面说一种最经典的主题模型-LDA（隐含狄利克雷分布）\"></a>下面说一种最经典的主题模型-LDA（隐含狄利克雷分布）</h4><p>LDA(Latent Dirichlet allocation)，是一种主题模型，它可以将[文档集]中每篇文档的主题按照概率分布的形式给出，从而通过分析一些文档抽取出它们的主题，然后根据主题给文本分类。它是一种无监督学习算法，在训练时不需要手工标注的训练集，需要的仅仅是文档集以及指定主题的数量k（这个K就是PLDA参数topic）即可。</p>\n<h4 id=\"目前机器学习PAI平台文本分析组件PLDA，它是Google对LDA的开源实现。\"><a href=\"#目前机器学习PAI平台文本分析组件PLDA，它是Google对LDA的开源实现。\" class=\"headerlink\" title=\"目前机器学习PAI平台文本分析组件PLDA，它是Google对LDA的开源实现。\"></a>目前机器学习PAI平台文本分析组件PLDA，它是Google对LDA的开源实现。</h4><h3 id=\"语料生成过程（语料就是我们需要分析的所有文本，即文本集）\"><a href=\"#语料生成过程（语料就是我们需要分析的所有文本，即文本集）\" class=\"headerlink\" title=\"语料生成过程（语料就是我们需要分析的所有文本，即文本集）\"></a>语料生成过程（语料就是我们需要分析的所有文本，即文本集）</h3><p>假设语料库中有M篇文档（在这里我们定义：z是主题, w是词, d是文档），其中W(m)表示第m篇文档中的词，Z(m)表示这些词对应的topic编号。所有的word和对应的topic如下表示：</p>\n<p>红色方框内即表示一篇文档是由若干个词组成的，每个词都对应一个主题。（就像一篇文章所有的词都是为了更好的表达主题而存在的）</p>\n<h3 id=\"下面我们思考当写一篇文章时你是怎么做的。\"><a href=\"#下面我们思考当写一篇文章时你是怎么做的。\" class=\"headerlink\" title=\"下面我们思考当写一篇文章时你是怎么做的。\"></a>下面我们思考当写一篇文章时你是怎么做的。</h3><p>假设你要写一篇文章，首先想好了主题（一个或多个），然后围绕这几个主题（比如”Arts””Budgets””Children””Education”）你会想到很多与之相关的词：</p>\n<p>最后我们就是用这些和主题相关的词完成了一篇文章，就像下图一样，不同的颜色代表不同主题下的词，从颜色能看出每个主题的下面的词出现概率是不相同的：</p>\n<p>上面的这个案例是我们在确定主题和词之后生成文章的步骤。然后伟大的数学家把这个过程抽象成了概率分布问题（关于如何抽象，当然是一大堆假设和公式推导，最后得出结论）</p>\n<p>生成这篇文章可以看作如下过程：</p>\n<p>首先以一定的概率在”Arts”、”Budgets”、”Children”、”Education”中选择一个主题</p>\n<p>然后再以一定的概率在这个主题下选择某个单词</p>\n<p>不断重复以上两个步骤，最终完成一篇文章</p>\n<p>这里的两次”以一定的概率”，后面会有解释。</p>\n<h3 id=\"通过上面的分析，我们知道了文章生成过程，下来来说LDA模型\"><a href=\"#通过上面的分析，我们知道了文章生成过程，下来来说LDA模型\" class=\"headerlink\" title=\"通过上面的分析，我们知道了文章生成过程，下来来说LDA模型\"></a>通过上面的分析，我们知道了文章生成过程，下来来说LDA模型</h3><p>《LDA数学八卦》中把文档生成过程抽象成了一个游戏，主要是为了解决刚才我们说的”以一定概率”的问题。上帝有两种类型骰子：</p>\n<p>上面红框里面内容是说，每个doc-topic骰子是一篇文章的所有主题。</p>\n<p>上帝在LDA模型中，玩文档生成游戏的规则是这样的：</p>\n<p>这个文档生成规则可以看作如下过程：</p>\n<h4 id=\"首先上帝有两大坛骰子\"><a href=\"#首先上帝有两大坛骰子\" class=\"headerlink\" title=\"首先上帝有两大坛骰子\"></a>首先上帝有两大坛骰子</h4><p>第一坛装的是doc-topic骰子，就是和所有文档相关的所有主题；</p>\n<p>第二坛装的是topic-word骰子，就是和所有主题相关的所有单词；</p>\n<h4 id=\"开始文档生成游戏\"><a href=\"#开始文档生成游戏\" class=\"headerlink\" title=\"开始文档生成游戏\"></a>开始文档生成游戏</h4><p>随机从topic-word坛子独立抽取K个骰子，编号为1，2，3…k</p>\n<p>随机从doc-topic坛子抽取一个骰子，然后重复如下过程生成文档中的词:</p>\n<p>投掷doc-topic骰子，得到一个topic编号z</p>\n<p>投掷刚才K个骰子中选择编号为z的那个骰子，得到一个词</p>\n<p>每次都是先生成一篇文档之后再生成第二篇，文档中每个词的生成都要投掷两次骰子，第一次投掷doc-topic骰子得到一个topic，第二次投掷topic-word骰子得到一个word，就是说生成文档中的一个词要投掷2次。如果语料中有N个词，那么上帝要抛2N次，轮换抛doc-topic和topic-word。实际上一些投掷顺序是可以交换的（这里有很多公式推导，最终得到这个顺序可以交换），我们可以等价交换这2N次投掷顺序，先抛N次doc-topic骰子，得到语料中所有词的topic，然后基于每个topic的编号，再抛N次topic-word骰子得到语料中所有word。</p>\n<p>于是上帝的游戏规则就变成了这样：</p>\n<p>这个过程是这样的：</p>\n<p>随机从topic-word坛子独立抽取K个骰子，编号为1，2，3…k</p>\n<p>随机抽取一个doc-topic骰子，然后抛出得到一个主题z，再次抽取doc-topic骰子，再抛出，得到一个主题z（注意：由于是再次抽取，所以不一定还是之前那篇文档的主题）；重复这个步骤就能得到语料中所有文档主题</p>\n<p>从头到尾抛我们抽到的doc-topic骰子，从最开始抽到的topic-word骰子中取相应编号（在1到k中拿）的骰子抛出，得到对应的word</p>\n<p>以面的过程是先生成了语料中所有的topic，然后生成了所有的word。在topic生成的情况下word顺序是可以交换的，即如果确定了topic k，就算和它相关的word不在同一篇文章中，也是可以交换的。</p>\n<p>…数学家们做了假设和分析，搞懂了原理，他们决定把这些用公式表示,于是就算啊算，用到了贝叶斯、Dirichlet-Multionmial共轭结构、Gibbs-Sampling采样（一堆公式）最终…</p>\n<p><strong>牛X的数学家（神）得到了一个公式：</strong></p>\n<p>这里面z，i，k，t，v，m…只要知道都是一系列参数就行，比如文档编号、topic编号、word编号、第k个topic产生的词中word t的个数、文章数量…</p>\n<p>这个公式右边就是p(topic|word)*p(word|topic)，概率就是doc–&gt;topic–&gt;word的路径概率：</p>\n<p>接下来任务有两个：</p>\n<p>这里用到了Gibbs-Sampling公式，它的意义就是在k条路径中采样，基于语料训练LDA模型，模型中参数可以基于采集到的样本进行评估（我们做这些都是为了得到上面式子的参数）。</p>\n<p>下面是训练过程：</p>\n<p>由这个topic-word频率矩阵我们可以计算出每一个p(word|topic)概率。</p>\n<p>Gibbs-Sampling收敛后统计每篇文档中topic的频率分布就可以计算出p(topic|doc)的概率。(PAI平台PLDA组件有六个输出桩后面会解释)</p>\n<p>LDA的核心公式如下：</p>\n<p>P(word|doc)=p(word|topic)*p(topic|doc)</p>\n<p><strong>通过计算可以得到任意一个topic对应文档d中单词w出现的概率，通过这个概率不断修正我们的参数。</strong></p>\n<ul>\n<li>有了模型，接下来做的就是对于新来的文档doc(new)计算topic语义分布。</li>\n</ul>\n<p>下面是具体计算过程：</p>\n<p>迭代过程即：首先产生一个均匀分布的随机数，然后根据上式计算每个转移主题的概率，通过累积概率判断随机数落在哪个new topic下，更新参数矩阵，如此迭代直至收敛。</p>\n<h3 id=\"回到我们机器学习PAI，先看下PLDA模块的6个输出桩\"><a href=\"#回到我们机器学习PAI，先看下PLDA模块的6个输出桩\" class=\"headerlink\" title=\"回到我们机器学习PAI，先看下PLDA模块的6个输出桩\"></a>回到我们机器学习PAI，先看下PLDA模块的6个输出桩</h3><ol>\n<li>输出桩1：词频，算法内部抽样后每个词在主题出现次数</li>\n<li>输出桩2：P(单词|主题)每个主题下词的概率</li>\n<li>输出桩3：P(主题|单词)每个单词对应各个主题的概率</li>\n<li>输出桩4：P(文档|主题)每个主题对应各个文档的概率</li>\n<li>输出桩5：P(主题|文档)每个文档对应主题的概率</li>\n<li>输出桩6：P(主题)每个主题的概率，表明在整个文档中的权重</li>\n</ol>\n<p>通过上面的公式推导，计算出关键的几个概率，通过贝叶斯公式这几个值都是可以算出来的。</p>\n<p>第5个是输出桩输出结果显示的是每篇文章对应的每个主题的概率，而这个概率在上面通过p(topic|doc)已经算出。</p>\n<p>在实验中我们设置参数topic=50，这个主题数是相对<strong>整个语料库</strong>而言的，我们最后看到的结果是这50个主题在每一篇文章上的分布情况。其它默认即可。对于默认的几个参数给予功能性的说明：</p>\n<p>我们将文章id列和主题概率分布列，得到每个主题在每篇文章的概率分布如下图所示：</p>\n<p>上面把文章从主题的维度表示成了一个向量。接下来就可以通过向量的距离实现聚类，从而实现文章分类。</p>\n<p>备注：图片丢失，原文链接在评论中。</p>\n"},{"title":"信息基础和计算方式","abbrlink":"c013043","date":"2020-06-28T07:59:25.000Z","_content":"\n### 相关概念\n\n#### 熵\n\n当一件事情有多种可能情况时，这件事情对某人而言具体是哪种情况的不确定性叫做**熵**。\n\n#### 信息\n\n能够消除该人对这件事情不确定性的事物叫做**信息**。信息是从多个可能状态中确定实际状态所需的**物理量**。\n\n#### 两者关系\n\n熵和信息的关系：数量相等，意义相反。获取信息 = 消除熵。\n\n#### 噪音 和 数据\n\n那些不能够消除某人对某件事情不确定性的事物被称为数据或噪音。噪音是干扰某人获取信息的事物，数据是噪音和信息的混合，需要用知识将其分离。\n\n#### 概率 和 熵 的区别\n\n概率是某件事情某个可能情况的确定性，熵是某件事情到底是哪种情况的不确定性。\n\n### 信息的计算\n\n信息是一个物理量，信息消除的是事件的不确定性。可以选择一个事件的不确定性作为参照，当想要测量其他事件的不确定性时，就看待测事件的不确定性相当于*多少个*参照事件的不确定性。这里的*多少个*就是信息量。\n\n#### 参照事件\n\n在这里*只考虑等概率事件*，即单个事件相互独立，概率相等。选择的参照事件不同，测量的信息量不同，对应的单位也不同，下面是常见的几种单位：\n\n（Ⅰ）如果参照事件只有2种等概率情况，那么测得的信息量的单位被称作 bit。（比如：抛硬币，只有正反两种情况，且概率相等，50%）\n\n（Ⅱ）如果参照事件有10种等概率情况，那么测得的信息量的单位被称作ban。（比如：抛一个正10面体🎲，有10种情况，且每种情况概率相等，10%）\n\n（Ⅲ）如果参照事件有e种等概率情况，那么测得的信息量的单位被称作nat。（类推，有e种等概率发生情况，每种情况发生的概率为 1/e）\n\n#### 如何计算\n\n下面通过例子来分析如何计算上面提到的*多少个*问题，这个值就是信息量。分两种情况：\n\n（Ⅰ）被测事件不确定性的所有可能情况*等概率*\n\n（Ⅱ）被测事件不确定性的所有可能情况*非等概率*\n\n#### 等概率\n\n假如，有一道单项选择题，提供ABCD四个选项，在不知道正确答案的情况下，四个选项对我们而言就是*四种不确定性*，不确定是ABCD中的哪一项。如果我们以抛硬币作为参照事件（最终计算的信息量单位为bit），等概率的*四种不确定情况*相当于一次抛出**2**枚硬币，那么我们就可以说：我们对这道题答案是ABCD中哪一项的不确定性为2bits。\n\n如果，这道单项选择题有ABCDEFGH八个选项，在不知道正确答案的情况下，他就有*八种不确定情况*，还是以抛硬币作为参照事件，那么相当于一次抛出**3**枚硬币（2^3=8），所以对这道题选项是哪一个的不确定性就是3bits。\n\n从上面可以看出，待测事件不确定情况的个数（m） 与 参照事件不确定情况的个数（n） 是*指数关系*进行累积的，表示为：3 = log_2 8，我们用m和n表示，那么上面两种情况信息量计算公式为：n = log_2 m，这里n就是*参照*事件为两种等概率情况下不确定性的*个数*，**信息量**。\n\n选择其他参照事件推演逻辑相同，计算所得信息量相同，只是单位不同而已，即实际客观存在的信息量是一样的（可以理解为1000g和1kg单位不同，实际客观存在的质量相同）。\n\n#### 非等概率\n\n非等概率情况，需要分别测量待测事件每种可能情况下的信息量，再乘以他们各自发生的概率，最后相加得到的值即为总信息量。\n\n假如，有一道单选题，提供ABCD四个选项，当被告知C选项有50%概率是正确答案时，信息量的计算方式为：\n\n1/6 * log_2 6/1 + 1/6 * log_2 6/1 + 1/2 * log_2 2/1 + 1/6 * log_2 1/6 = 1.79 bits\n\n\n\n参考：[YJango](https://www.zhihu.com/people/YJango)\t《学习观》 \n\n\n\n\n\n","source":"_posts/amount-of-information.md","raw":"---\ntitle: 信息基础和计算方式\ncategories: 理论\ntags:\n  - 信息\n  - 熵\nabbrlink: c013043\ndate: 2020-06-28 15:59:25\n---\n\n### 相关概念\n\n#### 熵\n\n当一件事情有多种可能情况时，这件事情对某人而言具体是哪种情况的不确定性叫做**熵**。\n\n#### 信息\n\n能够消除该人对这件事情不确定性的事物叫做**信息**。信息是从多个可能状态中确定实际状态所需的**物理量**。\n\n#### 两者关系\n\n熵和信息的关系：数量相等，意义相反。获取信息 = 消除熵。\n\n#### 噪音 和 数据\n\n那些不能够消除某人对某件事情不确定性的事物被称为数据或噪音。噪音是干扰某人获取信息的事物，数据是噪音和信息的混合，需要用知识将其分离。\n\n#### 概率 和 熵 的区别\n\n概率是某件事情某个可能情况的确定性，熵是某件事情到底是哪种情况的不确定性。\n\n### 信息的计算\n\n信息是一个物理量，信息消除的是事件的不确定性。可以选择一个事件的不确定性作为参照，当想要测量其他事件的不确定性时，就看待测事件的不确定性相当于*多少个*参照事件的不确定性。这里的*多少个*就是信息量。\n\n#### 参照事件\n\n在这里*只考虑等概率事件*，即单个事件相互独立，概率相等。选择的参照事件不同，测量的信息量不同，对应的单位也不同，下面是常见的几种单位：\n\n（Ⅰ）如果参照事件只有2种等概率情况，那么测得的信息量的单位被称作 bit。（比如：抛硬币，只有正反两种情况，且概率相等，50%）\n\n（Ⅱ）如果参照事件有10种等概率情况，那么测得的信息量的单位被称作ban。（比如：抛一个正10面体🎲，有10种情况，且每种情况概率相等，10%）\n\n（Ⅲ）如果参照事件有e种等概率情况，那么测得的信息量的单位被称作nat。（类推，有e种等概率发生情况，每种情况发生的概率为 1/e）\n\n#### 如何计算\n\n下面通过例子来分析如何计算上面提到的*多少个*问题，这个值就是信息量。分两种情况：\n\n（Ⅰ）被测事件不确定性的所有可能情况*等概率*\n\n（Ⅱ）被测事件不确定性的所有可能情况*非等概率*\n\n#### 等概率\n\n假如，有一道单项选择题，提供ABCD四个选项，在不知道正确答案的情况下，四个选项对我们而言就是*四种不确定性*，不确定是ABCD中的哪一项。如果我们以抛硬币作为参照事件（最终计算的信息量单位为bit），等概率的*四种不确定情况*相当于一次抛出**2**枚硬币，那么我们就可以说：我们对这道题答案是ABCD中哪一项的不确定性为2bits。\n\n如果，这道单项选择题有ABCDEFGH八个选项，在不知道正确答案的情况下，他就有*八种不确定情况*，还是以抛硬币作为参照事件，那么相当于一次抛出**3**枚硬币（2^3=8），所以对这道题选项是哪一个的不确定性就是3bits。\n\n从上面可以看出，待测事件不确定情况的个数（m） 与 参照事件不确定情况的个数（n） 是*指数关系*进行累积的，表示为：3 = log_2 8，我们用m和n表示，那么上面两种情况信息量计算公式为：n = log_2 m，这里n就是*参照*事件为两种等概率情况下不确定性的*个数*，**信息量**。\n\n选择其他参照事件推演逻辑相同，计算所得信息量相同，只是单位不同而已，即实际客观存在的信息量是一样的（可以理解为1000g和1kg单位不同，实际客观存在的质量相同）。\n\n#### 非等概率\n\n非等概率情况，需要分别测量待测事件每种可能情况下的信息量，再乘以他们各自发生的概率，最后相加得到的值即为总信息量。\n\n假如，有一道单选题，提供ABCD四个选项，当被告知C选项有50%概率是正确答案时，信息量的计算方式为：\n\n1/6 * log_2 6/1 + 1/6 * log_2 6/1 + 1/2 * log_2 2/1 + 1/6 * log_2 1/6 = 1.79 bits\n\n\n\n参考：[YJango](https://www.zhihu.com/people/YJango)\t《学习观》 \n\n\n\n\n\n","slug":"amount-of-information","published":1,"updated":"2020-07-05T12:12:04.311Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc9dk3cb000dnsvn5dql7skh","content":"<h3 id=\"相关概念\"><a href=\"#相关概念\" class=\"headerlink\" title=\"相关概念\"></a>相关概念</h3><h4 id=\"熵\"><a href=\"#熵\" class=\"headerlink\" title=\"熵\"></a>熵</h4><p>当一件事情有多种可能情况时，这件事情对某人而言具体是哪种情况的不确定性叫做<strong>熵</strong>。</p>\n<h4 id=\"信息\"><a href=\"#信息\" class=\"headerlink\" title=\"信息\"></a>信息</h4><p>能够消除该人对这件事情不确定性的事物叫做<strong>信息</strong>。信息是从多个可能状态中确定实际状态所需的<strong>物理量</strong>。</p>\n<h4 id=\"两者关系\"><a href=\"#两者关系\" class=\"headerlink\" title=\"两者关系\"></a>两者关系</h4><p>熵和信息的关系：数量相等，意义相反。获取信息 = 消除熵。</p>\n<h4 id=\"噪音-和-数据\"><a href=\"#噪音-和-数据\" class=\"headerlink\" title=\"噪音 和 数据\"></a>噪音 和 数据</h4><p>那些不能够消除某人对某件事情不确定性的事物被称为数据或噪音。噪音是干扰某人获取信息的事物，数据是噪音和信息的混合，需要用知识将其分离。</p>\n<h4 id=\"概率-和-熵-的区别\"><a href=\"#概率-和-熵-的区别\" class=\"headerlink\" title=\"概率 和 熵 的区别\"></a>概率 和 熵 的区别</h4><p>概率是某件事情某个可能情况的确定性，熵是某件事情到底是哪种情况的不确定性。</p>\n<h3 id=\"信息的计算\"><a href=\"#信息的计算\" class=\"headerlink\" title=\"信息的计算\"></a>信息的计算</h3><p>信息是一个物理量，信息消除的是事件的不确定性。可以选择一个事件的不确定性作为参照，当想要测量其他事件的不确定性时，就看待测事件的不确定性相当于<em>多少个</em>参照事件的不确定性。这里的<em>多少个</em>就是信息量。</p>\n<h4 id=\"参照事件\"><a href=\"#参照事件\" class=\"headerlink\" title=\"参照事件\"></a>参照事件</h4><p>在这里<em>只考虑等概率事件</em>，即单个事件相互独立，概率相等。选择的参照事件不同，测量的信息量不同，对应的单位也不同，下面是常见的几种单位：</p>\n<p>（Ⅰ）如果参照事件只有2种等概率情况，那么测得的信息量的单位被称作 bit。（比如：抛硬币，只有正反两种情况，且概率相等，50%）</p>\n<p>（Ⅱ）如果参照事件有10种等概率情况，那么测得的信息量的单位被称作ban。（比如：抛一个正10面体🎲，有10种情况，且每种情况概率相等，10%）</p>\n<p>（Ⅲ）如果参照事件有e种等概率情况，那么测得的信息量的单位被称作nat。（类推，有e种等概率发生情况，每种情况发生的概率为 1/e）</p>\n<h4 id=\"如何计算\"><a href=\"#如何计算\" class=\"headerlink\" title=\"如何计算\"></a>如何计算</h4><p>下面通过例子来分析如何计算上面提到的<em>多少个</em>问题，这个值就是信息量。分两种情况：</p>\n<p>（Ⅰ）被测事件不确定性的所有可能情况<em>等概率</em></p>\n<p>（Ⅱ）被测事件不确定性的所有可能情况<em>非等概率</em></p>\n<h4 id=\"等概率\"><a href=\"#等概率\" class=\"headerlink\" title=\"等概率\"></a>等概率</h4><p>假如，有一道单项选择题，提供ABCD四个选项，在不知道正确答案的情况下，四个选项对我们而言就是<em>四种不确定性</em>，不确定是ABCD中的哪一项。如果我们以抛硬币作为参照事件（最终计算的信息量单位为bit），等概率的<em>四种不确定情况</em>相当于一次抛出<strong>2</strong>枚硬币，那么我们就可以说：我们对这道题答案是ABCD中哪一项的不确定性为2bits。</p>\n<p>如果，这道单项选择题有ABCDEFGH八个选项，在不知道正确答案的情况下，他就有<em>八种不确定情况</em>，还是以抛硬币作为参照事件，那么相当于一次抛出<strong>3</strong>枚硬币（2^3=8），所以对这道题选项是哪一个的不确定性就是3bits。</p>\n<p>从上面可以看出，待测事件不确定情况的个数（m） 与 参照事件不确定情况的个数（n） 是<em>指数关系</em>进行累积的，表示为：3 = log_2 8，我们用m和n表示，那么上面两种情况信息量计算公式为：n = log_2 m，这里n就是<em>参照</em>事件为两种等概率情况下不确定性的<em>个数</em>，<strong>信息量</strong>。</p>\n<p>选择其他参照事件推演逻辑相同，计算所得信息量相同，只是单位不同而已，即实际客观存在的信息量是一样的（可以理解为1000g和1kg单位不同，实际客观存在的质量相同）。</p>\n<h4 id=\"非等概率\"><a href=\"#非等概率\" class=\"headerlink\" title=\"非等概率\"></a>非等概率</h4><p>非等概率情况，需要分别测量待测事件每种可能情况下的信息量，再乘以他们各自发生的概率，最后相加得到的值即为总信息量。</p>\n<p>假如，有一道单选题，提供ABCD四个选项，当被告知C选项有50%概率是正确答案时，信息量的计算方式为：</p>\n<p>1/6 * log_2 6/1 + 1/6 * log_2 6/1 + 1/2 * log_2 2/1 + 1/6 * log_2 1/6 = 1.79 bits</p>\n<p>参考：<a href=\"https://www.zhihu.com/people/YJango\" target=\"_blank\" rel=\"noopener\">YJango</a>    《学习观》 </p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"相关概念\"><a href=\"#相关概念\" class=\"headerlink\" title=\"相关概念\"></a>相关概念</h3><h4 id=\"熵\"><a href=\"#熵\" class=\"headerlink\" title=\"熵\"></a>熵</h4><p>当一件事情有多种可能情况时，这件事情对某人而言具体是哪种情况的不确定性叫做<strong>熵</strong>。</p>\n<h4 id=\"信息\"><a href=\"#信息\" class=\"headerlink\" title=\"信息\"></a>信息</h4><p>能够消除该人对这件事情不确定性的事物叫做<strong>信息</strong>。信息是从多个可能状态中确定实际状态所需的<strong>物理量</strong>。</p>\n<h4 id=\"两者关系\"><a href=\"#两者关系\" class=\"headerlink\" title=\"两者关系\"></a>两者关系</h4><p>熵和信息的关系：数量相等，意义相反。获取信息 = 消除熵。</p>\n<h4 id=\"噪音-和-数据\"><a href=\"#噪音-和-数据\" class=\"headerlink\" title=\"噪音 和 数据\"></a>噪音 和 数据</h4><p>那些不能够消除某人对某件事情不确定性的事物被称为数据或噪音。噪音是干扰某人获取信息的事物，数据是噪音和信息的混合，需要用知识将其分离。</p>\n<h4 id=\"概率-和-熵-的区别\"><a href=\"#概率-和-熵-的区别\" class=\"headerlink\" title=\"概率 和 熵 的区别\"></a>概率 和 熵 的区别</h4><p>概率是某件事情某个可能情况的确定性，熵是某件事情到底是哪种情况的不确定性。</p>\n<h3 id=\"信息的计算\"><a href=\"#信息的计算\" class=\"headerlink\" title=\"信息的计算\"></a>信息的计算</h3><p>信息是一个物理量，信息消除的是事件的不确定性。可以选择一个事件的不确定性作为参照，当想要测量其他事件的不确定性时，就看待测事件的不确定性相当于<em>多少个</em>参照事件的不确定性。这里的<em>多少个</em>就是信息量。</p>\n<h4 id=\"参照事件\"><a href=\"#参照事件\" class=\"headerlink\" title=\"参照事件\"></a>参照事件</h4><p>在这里<em>只考虑等概率事件</em>，即单个事件相互独立，概率相等。选择的参照事件不同，测量的信息量不同，对应的单位也不同，下面是常见的几种单位：</p>\n<p>（Ⅰ）如果参照事件只有2种等概率情况，那么测得的信息量的单位被称作 bit。（比如：抛硬币，只有正反两种情况，且概率相等，50%）</p>\n<p>（Ⅱ）如果参照事件有10种等概率情况，那么测得的信息量的单位被称作ban。（比如：抛一个正10面体🎲，有10种情况，且每种情况概率相等，10%）</p>\n<p>（Ⅲ）如果参照事件有e种等概率情况，那么测得的信息量的单位被称作nat。（类推，有e种等概率发生情况，每种情况发生的概率为 1/e）</p>\n<h4 id=\"如何计算\"><a href=\"#如何计算\" class=\"headerlink\" title=\"如何计算\"></a>如何计算</h4><p>下面通过例子来分析如何计算上面提到的<em>多少个</em>问题，这个值就是信息量。分两种情况：</p>\n<p>（Ⅰ）被测事件不确定性的所有可能情况<em>等概率</em></p>\n<p>（Ⅱ）被测事件不确定性的所有可能情况<em>非等概率</em></p>\n<h4 id=\"等概率\"><a href=\"#等概率\" class=\"headerlink\" title=\"等概率\"></a>等概率</h4><p>假如，有一道单项选择题，提供ABCD四个选项，在不知道正确答案的情况下，四个选项对我们而言就是<em>四种不确定性</em>，不确定是ABCD中的哪一项。如果我们以抛硬币作为参照事件（最终计算的信息量单位为bit），等概率的<em>四种不确定情况</em>相当于一次抛出<strong>2</strong>枚硬币，那么我们就可以说：我们对这道题答案是ABCD中哪一项的不确定性为2bits。</p>\n<p>如果，这道单项选择题有ABCDEFGH八个选项，在不知道正确答案的情况下，他就有<em>八种不确定情况</em>，还是以抛硬币作为参照事件，那么相当于一次抛出<strong>3</strong>枚硬币（2^3=8），所以对这道题选项是哪一个的不确定性就是3bits。</p>\n<p>从上面可以看出，待测事件不确定情况的个数（m） 与 参照事件不确定情况的个数（n） 是<em>指数关系</em>进行累积的，表示为：3 = log_2 8，我们用m和n表示，那么上面两种情况信息量计算公式为：n = log_2 m，这里n就是<em>参照</em>事件为两种等概率情况下不确定性的<em>个数</em>，<strong>信息量</strong>。</p>\n<p>选择其他参照事件推演逻辑相同，计算所得信息量相同，只是单位不同而已，即实际客观存在的信息量是一样的（可以理解为1000g和1kg单位不同，实际客观存在的质量相同）。</p>\n<h4 id=\"非等概率\"><a href=\"#非等概率\" class=\"headerlink\" title=\"非等概率\"></a>非等概率</h4><p>非等概率情况，需要分别测量待测事件每种可能情况下的信息量，再乘以他们各自发生的概率，最后相加得到的值即为总信息量。</p>\n<p>假如，有一道单选题，提供ABCD四个选项，当被告知C选项有50%概率是正确答案时，信息量的计算方式为：</p>\n<p>1/6 * log_2 6/1 + 1/6 * log_2 6/1 + 1/2 * log_2 2/1 + 1/6 * log_2 1/6 = 1.79 bits</p>\n<p>参考：<a href=\"https://www.zhihu.com/people/YJango\" target=\"_blank\" rel=\"noopener\">YJango</a>    《学习观》 </p>\n"},{"title":"Hello World","abbrlink":"4a17b156","date":"2020-06-07T10:50:35.000Z","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n\n测试！\n最后更新时间：2020/6/12 下午5:20:00\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\nabbrlink: 4a17b156\ndate: 2020-06-07 18:50:35\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n\n测试！\n最后更新时间：2020/6/12 下午5:20:00\n","slug":"hello-world","published":1,"updated":"2020-07-05T12:12:04.295Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc9dk3ci000hnsvn6c28bds7","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n<p>测试！<br>最后更新时间：2020/6/12 下午5:20:00</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n<p>测试！<br>最后更新时间：2020/6/12 下午5:20:00</p>\n"},{"title":"Java代码风格之常量","abbrlink":"ddb1142c","date":"2020-06-25T16:37:15.000Z","_content":"\n### 常量命名规范\n\n常量是作用域内保持不变的值。一般用`final`关键字修饰，根据作用域不同分为全局常量，类内常量，局部常量。\n\n#### 1.全局常量\n\n指类的公开静态属性，使用`public` static final 修饰。\n\n#### 2.类内常量\n\n指私有静态属性，使用`private` static final 修饰。\n\n#### 3.局部常量\n\n分为方法常量和参数常量。前者是方法或代码块内定义的常量，后者是在定义形参时增加 `final` 标识，表示此参数值不能被修改。\n\n下面是这些不同类型变量的示例：\n\n```java\npublic class Constant {\n    // 全局常量，类内常量：变量名称全大写，单词之间下划线分割\n    public static final String GLOBAL_CONSTANT = \"shared in global\";\n    private static final String CLASS_CONSTANT = \"shared in class\";\n    \n    public void f (String a) {\n        // 方法常量：变量名称小驼峰\n        final String methodContant = \"shared in method\";\n    }\n    \n    // 参数常量：b不可修改\n    public void g (final int b) {\n        // 编译出错，不允许对常量参数重新赋值\n        b = 3;\n    }\n}\n```\n\n### 禁用魔法值\n\n魔法值即共识层面上的常量，直接以具体的数值或字符出现在代码中。如下代码：\n\n```java\nString key = \"Id#taobao_\" + readeId;\ncache.put(key, value);\n```\n\n这段代码是保存信息到缓存中的方法，即使用魔法值组装key。如果在key拼接过程中错误的将`\"Id#taobao_\"`写成`\"Id#taobao\"`少了下划线，这就会导致缓存没有命中而去访问数据库，一般在测试环境数据量不大情况下并不容易发现这个问题的严重性，但是在大促时缓存失效导致数据库瞬间压力急剧上升，导致查询变慢。\n\n所以，即使类内常量和局部常量只用一次，也应该赋予一个有意义的名称，保证后期使用时*方便理解*和*值出同源*。\n\n### Enum枚举类型\n\n使用枚举类型定义全局常量都需要添加清晰的注释，比如业务相关信息或注意事项：\n\n```java\n// 定义交通灯枚举类\npublic enum ColorTypeEnum {\n    \n  RED(1, \"停\"),\n  GREEN(2, \"行\"),\n  YELLOW(3, \"等\");\n  private int status;\n  private String ledColor;\n\n  ColorTypeEnum(int status, String ledColor) {\n    this.status = status;\n    this.ledColor = ledColor;\n  }\n\n  public int getStatus() {\n    return status;\n  }\n\n  public String getLedColor() {\n    return ledColor;\n  }\n}\n\n// 测试类，获取红灯状态码\npublic class Test {\n    \n  public static void main(String[] args) {\n    System.out.println(ColorTypeEnum.RED.getStatus());\n  }\n}\n```\n\n### 抽象类\n\n使用不可实例化的抽象类的全局常量来表示交通灯状态和颜色：\n\n```java\n// 交通灯抽象类\npublic abstract class BaseColorStatus {\n\n  public static final int RED = 1;\n  public static final int GREEN = 2;\n  public static final int YELLOW = 3;\n}\n\n// 测试类，获取红灯状态码\npublic class Test {\n    \n  public static void main(String[] args) {\n    System.out.println(BaseColorStatus.RED);\n  }\n}\n```\n\n\n\n参考《码出高效Java开发手册》","source":"_posts/java-constant.md","raw":"---\ntitle: Java代码风格之常量\ncategories: Java\ntags:\n  - Java\n  - 开发规范\nabbrlink: ddb1142c\ndate: 2020-06-26 00:37:15\n---\n\n### 常量命名规范\n\n常量是作用域内保持不变的值。一般用`final`关键字修饰，根据作用域不同分为全局常量，类内常量，局部常量。\n\n#### 1.全局常量\n\n指类的公开静态属性，使用`public` static final 修饰。\n\n#### 2.类内常量\n\n指私有静态属性，使用`private` static final 修饰。\n\n#### 3.局部常量\n\n分为方法常量和参数常量。前者是方法或代码块内定义的常量，后者是在定义形参时增加 `final` 标识，表示此参数值不能被修改。\n\n下面是这些不同类型变量的示例：\n\n```java\npublic class Constant {\n    // 全局常量，类内常量：变量名称全大写，单词之间下划线分割\n    public static final String GLOBAL_CONSTANT = \"shared in global\";\n    private static final String CLASS_CONSTANT = \"shared in class\";\n    \n    public void f (String a) {\n        // 方法常量：变量名称小驼峰\n        final String methodContant = \"shared in method\";\n    }\n    \n    // 参数常量：b不可修改\n    public void g (final int b) {\n        // 编译出错，不允许对常量参数重新赋值\n        b = 3;\n    }\n}\n```\n\n### 禁用魔法值\n\n魔法值即共识层面上的常量，直接以具体的数值或字符出现在代码中。如下代码：\n\n```java\nString key = \"Id#taobao_\" + readeId;\ncache.put(key, value);\n```\n\n这段代码是保存信息到缓存中的方法，即使用魔法值组装key。如果在key拼接过程中错误的将`\"Id#taobao_\"`写成`\"Id#taobao\"`少了下划线，这就会导致缓存没有命中而去访问数据库，一般在测试环境数据量不大情况下并不容易发现这个问题的严重性，但是在大促时缓存失效导致数据库瞬间压力急剧上升，导致查询变慢。\n\n所以，即使类内常量和局部常量只用一次，也应该赋予一个有意义的名称，保证后期使用时*方便理解*和*值出同源*。\n\n### Enum枚举类型\n\n使用枚举类型定义全局常量都需要添加清晰的注释，比如业务相关信息或注意事项：\n\n```java\n// 定义交通灯枚举类\npublic enum ColorTypeEnum {\n    \n  RED(1, \"停\"),\n  GREEN(2, \"行\"),\n  YELLOW(3, \"等\");\n  private int status;\n  private String ledColor;\n\n  ColorTypeEnum(int status, String ledColor) {\n    this.status = status;\n    this.ledColor = ledColor;\n  }\n\n  public int getStatus() {\n    return status;\n  }\n\n  public String getLedColor() {\n    return ledColor;\n  }\n}\n\n// 测试类，获取红灯状态码\npublic class Test {\n    \n  public static void main(String[] args) {\n    System.out.println(ColorTypeEnum.RED.getStatus());\n  }\n}\n```\n\n### 抽象类\n\n使用不可实例化的抽象类的全局常量来表示交通灯状态和颜色：\n\n```java\n// 交通灯抽象类\npublic abstract class BaseColorStatus {\n\n  public static final int RED = 1;\n  public static final int GREEN = 2;\n  public static final int YELLOW = 3;\n}\n\n// 测试类，获取红灯状态码\npublic class Test {\n    \n  public static void main(String[] args) {\n    System.out.println(BaseColorStatus.RED);\n  }\n}\n```\n\n\n\n参考《码出高效Java开发手册》","slug":"java-constant","published":1,"updated":"2020-07-05T12:12:04.313Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc9dk3cl000insvn2pr1hp8a","content":"<h3 id=\"常量命名规范\"><a href=\"#常量命名规范\" class=\"headerlink\" title=\"常量命名规范\"></a>常量命名规范</h3><p>常量是作用域内保持不变的值。一般用<code>final</code>关键字修饰，根据作用域不同分为全局常量，类内常量，局部常量。</p>\n<h4 id=\"1-全局常量\"><a href=\"#1-全局常量\" class=\"headerlink\" title=\"1.全局常量\"></a>1.全局常量</h4><p>指类的公开静态属性，使用<code>public</code> static final 修饰。</p>\n<h4 id=\"2-类内常量\"><a href=\"#2-类内常量\" class=\"headerlink\" title=\"2.类内常量\"></a>2.类内常量</h4><p>指私有静态属性，使用<code>private</code> static final 修饰。</p>\n<h4 id=\"3-局部常量\"><a href=\"#3-局部常量\" class=\"headerlink\" title=\"3.局部常量\"></a>3.局部常量</h4><p>分为方法常量和参数常量。前者是方法或代码块内定义的常量，后者是在定义形参时增加 <code>final</code> 标识，表示此参数值不能被修改。</p>\n<p>下面是这些不同类型变量的示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Constant</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 全局常量，类内常量：变量名称全大写，单词之间下划线分割</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String GLOBAL_CONSTANT = <span class=\"string\">\"shared in global\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String CLASS_CONSTANT = <span class=\"string\">\"shared in class\"</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span> <span class=\"params\">(String a)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 方法常量：变量名称小驼峰</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> String methodContant = <span class=\"string\">\"shared in method\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 参数常量：b不可修改</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">g</span> <span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 编译出错，不允许对常量参数重新赋值</span></span><br><span class=\"line\">        b = <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"禁用魔法值\"><a href=\"#禁用魔法值\" class=\"headerlink\" title=\"禁用魔法值\"></a>禁用魔法值</h3><p>魔法值即共识层面上的常量，直接以具体的数值或字符出现在代码中。如下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String key = <span class=\"string\">\"Id#taobao_\"</span> + readeId;</span><br><span class=\"line\">cache.put(key, value);</span><br></pre></td></tr></table></figure>\n\n<p>这段代码是保存信息到缓存中的方法，即使用魔法值组装key。如果在key拼接过程中错误的将<code>&quot;Id#taobao_&quot;</code>写成<code>&quot;Id#taobao&quot;</code>少了下划线，这就会导致缓存没有命中而去访问数据库，一般在测试环境数据量不大情况下并不容易发现这个问题的严重性，但是在大促时缓存失效导致数据库瞬间压力急剧上升，导致查询变慢。</p>\n<p>所以，即使类内常量和局部常量只用一次，也应该赋予一个有意义的名称，保证后期使用时<em>方便理解</em>和<em>值出同源</em>。</p>\n<h3 id=\"Enum枚举类型\"><a href=\"#Enum枚举类型\" class=\"headerlink\" title=\"Enum枚举类型\"></a>Enum枚举类型</h3><p>使用枚举类型定义全局常量都需要添加清晰的注释，比如业务相关信息或注意事项：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义交通灯枚举类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> ColorTypeEnum &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">  RED(<span class=\"number\">1</span>, <span class=\"string\">\"停\"</span>),</span><br><span class=\"line\">  GREEN(<span class=\"number\">2</span>, <span class=\"string\">\"行\"</span>),</span><br><span class=\"line\">  YELLOW(<span class=\"number\">3</span>, <span class=\"string\">\"等\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> status;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String ledColor;</span><br><span class=\"line\"></span><br><span class=\"line\">  ColorTypeEnum(<span class=\"keyword\">int</span> status, String ledColor) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.status = status;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.ledColor = ledColor;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getStatus</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> status;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getLedColor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ledColor;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试类，获取红灯状态码</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(ColorTypeEnum.RED.getStatus());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h3><p>使用不可实例化的抽象类的全局常量来表示交通灯状态和颜色：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 交通灯抽象类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseColorStatus</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> RED = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> GREEN = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> YELLOW = <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试类，获取红灯状态码</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(BaseColorStatus.RED);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>参考《码出高效Java开发手册》</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"常量命名规范\"><a href=\"#常量命名规范\" class=\"headerlink\" title=\"常量命名规范\"></a>常量命名规范</h3><p>常量是作用域内保持不变的值。一般用<code>final</code>关键字修饰，根据作用域不同分为全局常量，类内常量，局部常量。</p>\n<h4 id=\"1-全局常量\"><a href=\"#1-全局常量\" class=\"headerlink\" title=\"1.全局常量\"></a>1.全局常量</h4><p>指类的公开静态属性，使用<code>public</code> static final 修饰。</p>\n<h4 id=\"2-类内常量\"><a href=\"#2-类内常量\" class=\"headerlink\" title=\"2.类内常量\"></a>2.类内常量</h4><p>指私有静态属性，使用<code>private</code> static final 修饰。</p>\n<h4 id=\"3-局部常量\"><a href=\"#3-局部常量\" class=\"headerlink\" title=\"3.局部常量\"></a>3.局部常量</h4><p>分为方法常量和参数常量。前者是方法或代码块内定义的常量，后者是在定义形参时增加 <code>final</code> 标识，表示此参数值不能被修改。</p>\n<p>下面是这些不同类型变量的示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Constant</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 全局常量，类内常量：变量名称全大写，单词之间下划线分割</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String GLOBAL_CONSTANT = <span class=\"string\">\"shared in global\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String CLASS_CONSTANT = <span class=\"string\">\"shared in class\"</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span> <span class=\"params\">(String a)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 方法常量：变量名称小驼峰</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> String methodContant = <span class=\"string\">\"shared in method\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 参数常量：b不可修改</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">g</span> <span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 编译出错，不允许对常量参数重新赋值</span></span><br><span class=\"line\">        b = <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"禁用魔法值\"><a href=\"#禁用魔法值\" class=\"headerlink\" title=\"禁用魔法值\"></a>禁用魔法值</h3><p>魔法值即共识层面上的常量，直接以具体的数值或字符出现在代码中。如下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String key = <span class=\"string\">\"Id#taobao_\"</span> + readeId;</span><br><span class=\"line\">cache.put(key, value);</span><br></pre></td></tr></table></figure>\n\n<p>这段代码是保存信息到缓存中的方法，即使用魔法值组装key。如果在key拼接过程中错误的将<code>&quot;Id#taobao_&quot;</code>写成<code>&quot;Id#taobao&quot;</code>少了下划线，这就会导致缓存没有命中而去访问数据库，一般在测试环境数据量不大情况下并不容易发现这个问题的严重性，但是在大促时缓存失效导致数据库瞬间压力急剧上升，导致查询变慢。</p>\n<p>所以，即使类内常量和局部常量只用一次，也应该赋予一个有意义的名称，保证后期使用时<em>方便理解</em>和<em>值出同源</em>。</p>\n<h3 id=\"Enum枚举类型\"><a href=\"#Enum枚举类型\" class=\"headerlink\" title=\"Enum枚举类型\"></a>Enum枚举类型</h3><p>使用枚举类型定义全局常量都需要添加清晰的注释，比如业务相关信息或注意事项：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义交通灯枚举类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> ColorTypeEnum &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">  RED(<span class=\"number\">1</span>, <span class=\"string\">\"停\"</span>),</span><br><span class=\"line\">  GREEN(<span class=\"number\">2</span>, <span class=\"string\">\"行\"</span>),</span><br><span class=\"line\">  YELLOW(<span class=\"number\">3</span>, <span class=\"string\">\"等\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> status;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String ledColor;</span><br><span class=\"line\"></span><br><span class=\"line\">  ColorTypeEnum(<span class=\"keyword\">int</span> status, String ledColor) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.status = status;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.ledColor = ledColor;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getStatus</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> status;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getLedColor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ledColor;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试类，获取红灯状态码</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(ColorTypeEnum.RED.getStatus());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h3><p>使用不可实例化的抽象类的全局常量来表示交通灯状态和颜色：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 交通灯抽象类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseColorStatus</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> RED = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> GREEN = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> YELLOW = <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试类，获取红灯状态码</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(BaseColorStatus.RED);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>参考《码出高效Java开发手册》</p>\n"},{"title":"决策树构造原理","abbrlink":"257cbae6","date":"2020-07-05T04:34:03.000Z","typora-root-url":"决策树构造原理","_content":"\n### Hexo插入图片测试\n\n在Hexo中插入图片，可以通过将 `config.yml` 文件中的 `post_asset_folder` 选项设为 `true` 来打开。\n\n### 决策树模型\n\n决策树是一种非常受欢迎的分类和预测工具，本文主要讨论用于分类的决策树，如结果是Yes or No，或者属于ABC哪种类别等*非连续，离散型*预测。决策树是一个树状结构的流程图，由下面几个元素构成，通过一幅图说明：\n\n![](/tree.png)\n\n非叶子节点（内部节点）：表示在一个特征或属性，如上图中Outlook，Humidity，wind\n\n分支：表示特征或属性在值域上的一个结果，如天气的Sunny，Overcast，Rain\n\n叶子节点（终端节点）：决策的结果，拥有一个分类标签，如上图中YES/NO\n\n### 决策树生成\n\n构造的基本思想是随着树深度的增加，内部节点的熵迅速降低（分裂后子集就越\"纯\"），越快越好，这样能使树的高度最矮。\n\n下面通过一个例子构造出决策树，重点是记录实现过程\n\n![](/PlayTennis.png)\n\n假设在上面的数据集E中，有4中类别的数据用ABCD顺序表示，下面说明如何使用ID3算法选择数据集中哪个特征作为第一个节点，首先说明用到的几个概念：\n\n#### 信息增益\n\n信息熵表示的是不确定度。均匀分布时，不确定度最大，此时熵就最大。当选择某个特征对数据集进行分类时，分类后的数据集信息熵会比分类前的小，其差值表示为`信息增益`。信息增益可以衡量<u>某个特征对分类结果的影响</u>大小。\n\n![](/img04.png)\n\n#### 特征作用前的熵 （经验熵）\n\n![](/img02.png)\n\n#### 特征作用后的熵\n\n![](/img03.png)\n\n#### ID3计算过程\n\n上面的数据集在没有任何特征作用下，只通过观察是否去打球的概率计算的`熵`(经验熵)为：\n\nH(E)  = -(9/14)log_2(9/14)-(5/14)log_2(5/14) = 0.940\n\n##### 确定哪一个特征做根节点\n\n我们需要分别计算在已知的4种特征情况下，是否打球的熵值都为多少，这样能区分每个特征对结果的重要性。首先计算如果**outlook**在不同取值时打球和不打球的熵值：\n\noutlook = sunny --> 共5次，2次打球，3次不打球。熵 ：-(2/5)log_2(2/5)-(3/5)log_2(3/5) = 0.971 \n\noutlook = overcost --> 共4次，都去打球了， 熵：-(1)log_2(1) = 0\n\noutlook = rainy --> 共5次，3次打球，2次没去。熵：-(3/5)log_2(3/5)-(2/5)log_2(2/5) = 0.971\n\n🏐所以当已知outlook的情况下，打球的不确定性，即特征作用后的熵为：5/14 * 0.971 + 4/14 * 0 + 5/14 * 0.971 = 0.693\n\n根据公式计算出 信息增益 （gain）为 ： g(E, A) = 0.940 - 0.693 = 0.247。\n\n同理可得已知其他特征时计算的熵值：g(E, B) = 0.029\tg(E, C) = 0.152\tg(E, D) = 0.048\n\n结论：g(E, A) 最大，说明使用特征A能使系统的熵下降最快，所以第一个节点（根节点）就选择`outlook`\n\n##### 接下来计算第二个节点\n\n在BCD三个特征下，计算系统的熵， 和每个特征作为已知条件下的熵，最终得到信息增益，选择最大的作为第二个节点。\n\n以此类推到系统熵下`降为0`结束构造。\n\n上面这种通过信息增益选择特征构造决策树的方式就是ID3算法。\n\n### 扩展（待补充）\n\nC4.5 -- 信息增益率\n\nCART -- \n\n### 剪枝（待补充）\n\n","source":"_posts/决策树构造原理.md","raw":"---\ntitle: 决策树构造原理\ncategories: 算法\ntags: 决策树\nabbrlink: 257cbae6\ndate: 2020-07-05 12:34:03\ntypora-root-url: 决策树构造原理\n---\n\n### Hexo插入图片测试\n\n在Hexo中插入图片，可以通过将 `config.yml` 文件中的 `post_asset_folder` 选项设为 `true` 来打开。\n\n### 决策树模型\n\n决策树是一种非常受欢迎的分类和预测工具，本文主要讨论用于分类的决策树，如结果是Yes or No，或者属于ABC哪种类别等*非连续，离散型*预测。决策树是一个树状结构的流程图，由下面几个元素构成，通过一幅图说明：\n\n![](/tree.png)\n\n非叶子节点（内部节点）：表示在一个特征或属性，如上图中Outlook，Humidity，wind\n\n分支：表示特征或属性在值域上的一个结果，如天气的Sunny，Overcast，Rain\n\n叶子节点（终端节点）：决策的结果，拥有一个分类标签，如上图中YES/NO\n\n### 决策树生成\n\n构造的基本思想是随着树深度的增加，内部节点的熵迅速降低（分裂后子集就越\"纯\"），越快越好，这样能使树的高度最矮。\n\n下面通过一个例子构造出决策树，重点是记录实现过程\n\n![](/PlayTennis.png)\n\n假设在上面的数据集E中，有4中类别的数据用ABCD顺序表示，下面说明如何使用ID3算法选择数据集中哪个特征作为第一个节点，首先说明用到的几个概念：\n\n#### 信息增益\n\n信息熵表示的是不确定度。均匀分布时，不确定度最大，此时熵就最大。当选择某个特征对数据集进行分类时，分类后的数据集信息熵会比分类前的小，其差值表示为`信息增益`。信息增益可以衡量<u>某个特征对分类结果的影响</u>大小。\n\n![](/img04.png)\n\n#### 特征作用前的熵 （经验熵）\n\n![](/img02.png)\n\n#### 特征作用后的熵\n\n![](/img03.png)\n\n#### ID3计算过程\n\n上面的数据集在没有任何特征作用下，只通过观察是否去打球的概率计算的`熵`(经验熵)为：\n\nH(E)  = -(9/14)log_2(9/14)-(5/14)log_2(5/14) = 0.940\n\n##### 确定哪一个特征做根节点\n\n我们需要分别计算在已知的4种特征情况下，是否打球的熵值都为多少，这样能区分每个特征对结果的重要性。首先计算如果**outlook**在不同取值时打球和不打球的熵值：\n\noutlook = sunny --> 共5次，2次打球，3次不打球。熵 ：-(2/5)log_2(2/5)-(3/5)log_2(3/5) = 0.971 \n\noutlook = overcost --> 共4次，都去打球了， 熵：-(1)log_2(1) = 0\n\noutlook = rainy --> 共5次，3次打球，2次没去。熵：-(3/5)log_2(3/5)-(2/5)log_2(2/5) = 0.971\n\n🏐所以当已知outlook的情况下，打球的不确定性，即特征作用后的熵为：5/14 * 0.971 + 4/14 * 0 + 5/14 * 0.971 = 0.693\n\n根据公式计算出 信息增益 （gain）为 ： g(E, A) = 0.940 - 0.693 = 0.247。\n\n同理可得已知其他特征时计算的熵值：g(E, B) = 0.029\tg(E, C) = 0.152\tg(E, D) = 0.048\n\n结论：g(E, A) 最大，说明使用特征A能使系统的熵下降最快，所以第一个节点（根节点）就选择`outlook`\n\n##### 接下来计算第二个节点\n\n在BCD三个特征下，计算系统的熵， 和每个特征作为已知条件下的熵，最终得到信息增益，选择最大的作为第二个节点。\n\n以此类推到系统熵下`降为0`结束构造。\n\n上面这种通过信息增益选择特征构造决策树的方式就是ID3算法。\n\n### 扩展（待补充）\n\nC4.5 -- 信息增益率\n\nCART -- \n\n### 剪枝（待补充）\n\n","slug":"决策树构造原理","published":1,"updated":"2020-07-05T17:52:56.864Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc9dk3cs000mnsvn9sup35ww","content":"<h3 id=\"Hexo插入图片测试\"><a href=\"#Hexo插入图片测试\" class=\"headerlink\" title=\"Hexo插入图片测试\"></a>Hexo插入图片测试</h3><p>在Hexo中插入图片，可以通过将 <code>config.yml</code> 文件中的 <code>post_asset_folder</code> 选项设为 <code>true</code> 来打开。</p>\n<h3 id=\"决策树模型\"><a href=\"#决策树模型\" class=\"headerlink\" title=\"决策树模型\"></a>决策树模型</h3><p>决策树是一种非常受欢迎的分类和预测工具，本文主要讨论用于分类的决策树，如结果是Yes or No，或者属于ABC哪种类别等<em>非连续，离散型</em>预测。决策树是一个树状结构的流程图，由下面几个元素构成，通过一幅图说明：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"/my-blog/posts/257cbae6/tree.png\" alt title>\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n\n<p>非叶子节点（内部节点）：表示在一个特征或属性，如上图中Outlook，Humidity，wind</p>\n<p>分支：表示特征或属性在值域上的一个结果，如天气的Sunny，Overcast，Rain</p>\n<p>叶子节点（终端节点）：决策的结果，拥有一个分类标签，如上图中YES/NO</p>\n<h3 id=\"决策树生成\"><a href=\"#决策树生成\" class=\"headerlink\" title=\"决策树生成\"></a>决策树生成</h3><p>构造的基本思想是随着树深度的增加，内部节点的熵迅速降低（分裂后子集就越”纯”），越快越好，这样能使树的高度最矮。</p>\n<p>下面通过一个例子构造出决策树，重点是记录实现过程</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"/my-blog/posts/257cbae6/PlayTennis.png\" alt title>\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n\n<p>假设在上面的数据集E中，有4中类别的数据用ABCD顺序表示，下面说明如何使用ID3算法选择数据集中哪个特征作为第一个节点，首先说明用到的几个概念：</p>\n<h4 id=\"信息增益\"><a href=\"#信息增益\" class=\"headerlink\" title=\"信息增益\"></a>信息增益</h4><p>信息熵表示的是不确定度。均匀分布时，不确定度最大，此时熵就最大。当选择某个特征对数据集进行分类时，分类后的数据集信息熵会比分类前的小，其差值表示为<code>信息增益</code>。信息增益可以衡量<u>某个特征对分类结果的影响</u>大小。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"/my-blog/posts/257cbae6/img04.png\" alt title>\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n\n<h4 id=\"特征作用前的熵-（经验熵）\"><a href=\"#特征作用前的熵-（经验熵）\" class=\"headerlink\" title=\"特征作用前的熵 （经验熵）\"></a>特征作用前的熵 （经验熵）</h4><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"/my-blog/posts/257cbae6/img02.png\" alt title>\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n\n<h4 id=\"特征作用后的熵\"><a href=\"#特征作用后的熵\" class=\"headerlink\" title=\"特征作用后的熵\"></a>特征作用后的熵</h4><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"/my-blog/posts/257cbae6/img03.png\" alt title>\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n\n<h4 id=\"ID3计算过程\"><a href=\"#ID3计算过程\" class=\"headerlink\" title=\"ID3计算过程\"></a>ID3计算过程</h4><p>上面的数据集在没有任何特征作用下，只通过观察是否去打球的概率计算的<code>熵</code>(经验熵)为：</p>\n<p>H(E)  = -(9/14)log_2(9/14)-(5/14)log_2(5/14) = 0.940</p>\n<h5 id=\"确定哪一个特征做根节点\"><a href=\"#确定哪一个特征做根节点\" class=\"headerlink\" title=\"确定哪一个特征做根节点\"></a>确定哪一个特征做根节点</h5><p>我们需要分别计算在已知的4种特征情况下，是否打球的熵值都为多少，这样能区分每个特征对结果的重要性。首先计算如果<strong>outlook</strong>在不同取值时打球和不打球的熵值：</p>\n<p>outlook = sunny –&gt; 共5次，2次打球，3次不打球。熵 ：-(2/5)log_2(2/5)-(3/5)log_2(3/5) = 0.971 </p>\n<p>outlook = overcost –&gt; 共4次，都去打球了， 熵：-(1)log_2(1) = 0</p>\n<p>outlook = rainy –&gt; 共5次，3次打球，2次没去。熵：-(3/5)log_2(3/5)-(2/5)log_2(2/5) = 0.971</p>\n<p>🏐所以当已知outlook的情况下，打球的不确定性，即特征作用后的熵为：5/14 * 0.971 + 4/14 * 0 + 5/14 * 0.971 = 0.693</p>\n<p>根据公式计算出 信息增益 （gain）为 ： g(E, A) = 0.940 - 0.693 = 0.247。</p>\n<p>同理可得已知其他特征时计算的熵值：g(E, B) = 0.029    g(E, C) = 0.152    g(E, D) = 0.048</p>\n<p>结论：g(E, A) 最大，说明使用特征A能使系统的熵下降最快，所以第一个节点（根节点）就选择<code>outlook</code></p>\n<h5 id=\"接下来计算第二个节点\"><a href=\"#接下来计算第二个节点\" class=\"headerlink\" title=\"接下来计算第二个节点\"></a>接下来计算第二个节点</h5><p>在BCD三个特征下，计算系统的熵， 和每个特征作为已知条件下的熵，最终得到信息增益，选择最大的作为第二个节点。</p>\n<p>以此类推到系统熵下<code>降为0</code>结束构造。</p>\n<p>上面这种通过信息增益选择特征构造决策树的方式就是ID3算法。</p>\n<h3 id=\"扩展（待补充）\"><a href=\"#扩展（待补充）\" class=\"headerlink\" title=\"扩展（待补充）\"></a>扩展（待补充）</h3><p>C4.5 – 信息增益率</p>\n<p>CART – </p>\n<h3 id=\"剪枝（待补充）\"><a href=\"#剪枝（待补充）\" class=\"headerlink\" title=\"剪枝（待补充）\"></a>剪枝（待补充）</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Hexo插入图片测试\"><a href=\"#Hexo插入图片测试\" class=\"headerlink\" title=\"Hexo插入图片测试\"></a>Hexo插入图片测试</h3><p>在Hexo中插入图片，可以通过将 <code>config.yml</code> 文件中的 <code>post_asset_folder</code> 选项设为 <code>true</code> 来打开。</p>\n<h3 id=\"决策树模型\"><a href=\"#决策树模型\" class=\"headerlink\" title=\"决策树模型\"></a>决策树模型</h3><p>决策树是一种非常受欢迎的分类和预测工具，本文主要讨论用于分类的决策树，如结果是Yes or No，或者属于ABC哪种类别等<em>非连续，离散型</em>预测。决策树是一个树状结构的流程图，由下面几个元素构成，通过一幅图说明：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"/my-blog/posts/257cbae6/tree.png\" alt title>\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n\n<p>非叶子节点（内部节点）：表示在一个特征或属性，如上图中Outlook，Humidity，wind</p>\n<p>分支：表示特征或属性在值域上的一个结果，如天气的Sunny，Overcast，Rain</p>\n<p>叶子节点（终端节点）：决策的结果，拥有一个分类标签，如上图中YES/NO</p>\n<h3 id=\"决策树生成\"><a href=\"#决策树生成\" class=\"headerlink\" title=\"决策树生成\"></a>决策树生成</h3><p>构造的基本思想是随着树深度的增加，内部节点的熵迅速降低（分裂后子集就越”纯”），越快越好，这样能使树的高度最矮。</p>\n<p>下面通过一个例子构造出决策树，重点是记录实现过程</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"/my-blog/posts/257cbae6/PlayTennis.png\" alt title>\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n\n<p>假设在上面的数据集E中，有4中类别的数据用ABCD顺序表示，下面说明如何使用ID3算法选择数据集中哪个特征作为第一个节点，首先说明用到的几个概念：</p>\n<h4 id=\"信息增益\"><a href=\"#信息增益\" class=\"headerlink\" title=\"信息增益\"></a>信息增益</h4><p>信息熵表示的是不确定度。均匀分布时，不确定度最大，此时熵就最大。当选择某个特征对数据集进行分类时，分类后的数据集信息熵会比分类前的小，其差值表示为<code>信息增益</code>。信息增益可以衡量<u>某个特征对分类结果的影响</u>大小。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"/my-blog/posts/257cbae6/img04.png\" alt title>\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n\n<h4 id=\"特征作用前的熵-（经验熵）\"><a href=\"#特征作用前的熵-（经验熵）\" class=\"headerlink\" title=\"特征作用前的熵 （经验熵）\"></a>特征作用前的熵 （经验熵）</h4><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"/my-blog/posts/257cbae6/img02.png\" alt title>\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n\n<h4 id=\"特征作用后的熵\"><a href=\"#特征作用后的熵\" class=\"headerlink\" title=\"特征作用后的熵\"></a>特征作用后的熵</h4><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"/my-blog/posts/257cbae6/img03.png\" alt title>\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n\n<h4 id=\"ID3计算过程\"><a href=\"#ID3计算过程\" class=\"headerlink\" title=\"ID3计算过程\"></a>ID3计算过程</h4><p>上面的数据集在没有任何特征作用下，只通过观察是否去打球的概率计算的<code>熵</code>(经验熵)为：</p>\n<p>H(E)  = -(9/14)log_2(9/14)-(5/14)log_2(5/14) = 0.940</p>\n<h5 id=\"确定哪一个特征做根节点\"><a href=\"#确定哪一个特征做根节点\" class=\"headerlink\" title=\"确定哪一个特征做根节点\"></a>确定哪一个特征做根节点</h5><p>我们需要分别计算在已知的4种特征情况下，是否打球的熵值都为多少，这样能区分每个特征对结果的重要性。首先计算如果<strong>outlook</strong>在不同取值时打球和不打球的熵值：</p>\n<p>outlook = sunny –&gt; 共5次，2次打球，3次不打球。熵 ：-(2/5)log_2(2/5)-(3/5)log_2(3/5) = 0.971 </p>\n<p>outlook = overcost –&gt; 共4次，都去打球了， 熵：-(1)log_2(1) = 0</p>\n<p>outlook = rainy –&gt; 共5次，3次打球，2次没去。熵：-(3/5)log_2(3/5)-(2/5)log_2(2/5) = 0.971</p>\n<p>🏐所以当已知outlook的情况下，打球的不确定性，即特征作用后的熵为：5/14 * 0.971 + 4/14 * 0 + 5/14 * 0.971 = 0.693</p>\n<p>根据公式计算出 信息增益 （gain）为 ： g(E, A) = 0.940 - 0.693 = 0.247。</p>\n<p>同理可得已知其他特征时计算的熵值：g(E, B) = 0.029    g(E, C) = 0.152    g(E, D) = 0.048</p>\n<p>结论：g(E, A) 最大，说明使用特征A能使系统的熵下降最快，所以第一个节点（根节点）就选择<code>outlook</code></p>\n<h5 id=\"接下来计算第二个节点\"><a href=\"#接下来计算第二个节点\" class=\"headerlink\" title=\"接下来计算第二个节点\"></a>接下来计算第二个节点</h5><p>在BCD三个特征下，计算系统的熵， 和每个特征作为已知条件下的熵，最终得到信息增益，选择最大的作为第二个节点。</p>\n<p>以此类推到系统熵下<code>降为0</code>结束构造。</p>\n<p>上面这种通过信息增益选择特征构造决策树的方式就是ID3算法。</p>\n<h3 id=\"扩展（待补充）\"><a href=\"#扩展（待补充）\" class=\"headerlink\" title=\"扩展（待补充）\"></a>扩展（待补充）</h3><p>C4.5 – 信息增益率</p>\n<p>CART – </p>\n<h3 id=\"剪枝（待补充）\"><a href=\"#剪枝（待补充）\" class=\"headerlink\" title=\"剪枝（待补充）\"></a>剪枝（待补充）</h3>"},{"title":"常用工具V1.0","abbrlink":"16f679cd","date":"2020-06-15T14:03:15.000Z","_content":"工作中常用的一些工具，以Windows上软件，Chrome插件和网页为主，整理记录方便自己查找。个人而言从发现一款软件，到最后能长期使用，大致经历的过程是这样的：\n\n#### 1.是否主流\n\n相信大家的选择。一般来说用户基数大的软件，都有不错的体验和安全性，产品维护的周期也会比较长。\n\n#### 2.是否免费\n\n好的产品前期都会给用户充足的体验时间。如果使用一段时间我发现这款软件确实好用而且费用又付的起，他能给我带来的收益绝不止软件价钱本身，我会选择付费。（太贵当我没说，白嫖乞丐版🤐）\n\n#### 3.是否开源\n\n开源≠免费，虽然很多开源软件是免费的。开源软件一般都是大神（们）用爱发电的结晶，代码透明相对安全，多人协作让功能更新和版本迭代也变得比较快，如果体验做的不错很容易成为爆款。\n\n#### 4.是否易用\n\n易用也是比较关键的。一般我会考虑的几点因素：\n\n1. 访问速度快慢：有些软件从功能开发，界面设计，到用户体验都很不错，做的很好无奈可能是由于还没开拓国内市场（慢到无法访问），导致综合体验大打折扣，所以并不是很推荐\n2. 操作简单方便：上手容易，功能明确，操作简单，界面美观，软件稳定即可（其实很难）\n3. 是否支持中文：最喜欢Simplified Chinese，第二选择是English。不过大多数软件都是开发的英文版本，后期做的国际化处理👩‍🎓\n\n综合以上4个方面的考量，当我需要找一款工具软件时，就有了比较合理的选择方向。下面是我常用的一些工具：\n\n📌 在线作图\t|\t[processon](https://www.processon.com/)\t|\t[excalidraw](https://excalidraw.com/)\t|\t[diagrams](https://app.diagrams.net/)\t|\t[ASCIIFlow](http://asciiflow.com/)\t|\n\n📌 代码编辑器\t|\t[Sublime Text](https://www.sublimetext.com/)\t|\t[VS Code](https://code.visualstudio.com/)\t|\n\n📌 笔记/TODO\t|\t[Joplin](https://joplinapp.org/)\t|\t[Notion](https://www.notion.so/)\t|\t[印象笔记](https://www.yinxiang.com/)\t|\n\n📌 文件同步\t|\t[坚果云](https://www.jianguoyun.com/)\t|\n\n📌 MySQL GUI\t|\t[SQLyog Community Edition](https://github.com/webyog/sqlyog-community/blob/master/README.md)\t|\n\n📌 文件比较\t|\t[Diffinity](https://truehumandesign.se/s_diffinity.php)\t|\t[diffchecker](https://www.diffchecker.com/)\t|\t[Meld](https://meldmerge.org/)\t|\n\n📌 代码转换\t|\t[jsonschema2pojo](http://www.jsonschema2pojo.org/)\t|\t[json.cn](https://www.json.cn/)\t|\t[JSONFormatter](https://www.jsonformatter.io/)\t|\t[URLEncoder](https://www.urlencoder.io/)\t|\t[Base64Encoder](https://www.base64encoder.io/)\t|\n\n📌 变量命名\t|\t[P8Z](http://p8z.fun/)\t|\t[codelf](https://unbug.github.io/codelf/)\t|\n\n📌 GitHub下载\t|\thttp://g.widyun.com/\t|\t[GitZip for github](https://gitzip.org/)\t|\t[GitZip](https://kinolien.github.io/gitzip/)\t|\n\n📌 截图贴图\t|\t[snipaste](https://zh.snipaste.com/)\t|\t\n\n持续更新\n","source":"_posts/常用效率工具1-0.md","raw":"---\ntitle: 常用工具V1.0\ncategories: 工具\ntags: 开发\nabbrlink: 16f679cd\ndate: 2020-06-15 22:03:15\n---\n工作中常用的一些工具，以Windows上软件，Chrome插件和网页为主，整理记录方便自己查找。个人而言从发现一款软件，到最后能长期使用，大致经历的过程是这样的：\n\n#### 1.是否主流\n\n相信大家的选择。一般来说用户基数大的软件，都有不错的体验和安全性，产品维护的周期也会比较长。\n\n#### 2.是否免费\n\n好的产品前期都会给用户充足的体验时间。如果使用一段时间我发现这款软件确实好用而且费用又付的起，他能给我带来的收益绝不止软件价钱本身，我会选择付费。（太贵当我没说，白嫖乞丐版🤐）\n\n#### 3.是否开源\n\n开源≠免费，虽然很多开源软件是免费的。开源软件一般都是大神（们）用爱发电的结晶，代码透明相对安全，多人协作让功能更新和版本迭代也变得比较快，如果体验做的不错很容易成为爆款。\n\n#### 4.是否易用\n\n易用也是比较关键的。一般我会考虑的几点因素：\n\n1. 访问速度快慢：有些软件从功能开发，界面设计，到用户体验都很不错，做的很好无奈可能是由于还没开拓国内市场（慢到无法访问），导致综合体验大打折扣，所以并不是很推荐\n2. 操作简单方便：上手容易，功能明确，操作简单，界面美观，软件稳定即可（其实很难）\n3. 是否支持中文：最喜欢Simplified Chinese，第二选择是English。不过大多数软件都是开发的英文版本，后期做的国际化处理👩‍🎓\n\n综合以上4个方面的考量，当我需要找一款工具软件时，就有了比较合理的选择方向。下面是我常用的一些工具：\n\n📌 在线作图\t|\t[processon](https://www.processon.com/)\t|\t[excalidraw](https://excalidraw.com/)\t|\t[diagrams](https://app.diagrams.net/)\t|\t[ASCIIFlow](http://asciiflow.com/)\t|\n\n📌 代码编辑器\t|\t[Sublime Text](https://www.sublimetext.com/)\t|\t[VS Code](https://code.visualstudio.com/)\t|\n\n📌 笔记/TODO\t|\t[Joplin](https://joplinapp.org/)\t|\t[Notion](https://www.notion.so/)\t|\t[印象笔记](https://www.yinxiang.com/)\t|\n\n📌 文件同步\t|\t[坚果云](https://www.jianguoyun.com/)\t|\n\n📌 MySQL GUI\t|\t[SQLyog Community Edition](https://github.com/webyog/sqlyog-community/blob/master/README.md)\t|\n\n📌 文件比较\t|\t[Diffinity](https://truehumandesign.se/s_diffinity.php)\t|\t[diffchecker](https://www.diffchecker.com/)\t|\t[Meld](https://meldmerge.org/)\t|\n\n📌 代码转换\t|\t[jsonschema2pojo](http://www.jsonschema2pojo.org/)\t|\t[json.cn](https://www.json.cn/)\t|\t[JSONFormatter](https://www.jsonformatter.io/)\t|\t[URLEncoder](https://www.urlencoder.io/)\t|\t[Base64Encoder](https://www.base64encoder.io/)\t|\n\n📌 变量命名\t|\t[P8Z](http://p8z.fun/)\t|\t[codelf](https://unbug.github.io/codelf/)\t|\n\n📌 GitHub下载\t|\thttp://g.widyun.com/\t|\t[GitZip for github](https://gitzip.org/)\t|\t[GitZip](https://kinolien.github.io/gitzip/)\t|\n\n📌 截图贴图\t|\t[snipaste](https://zh.snipaste.com/)\t|\t\n\n持续更新\n","slug":"常用效率工具1-0","published":1,"updated":"2020-07-05T12:12:04.318Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc9dk3cv000onsvn3b3761ql","content":"<p>工作中常用的一些工具，以Windows上软件，Chrome插件和网页为主，整理记录方便自己查找。个人而言从发现一款软件，到最后能长期使用，大致经历的过程是这样的：</p>\n<h4 id=\"1-是否主流\"><a href=\"#1-是否主流\" class=\"headerlink\" title=\"1.是否主流\"></a>1.是否主流</h4><p>相信大家的选择。一般来说用户基数大的软件，都有不错的体验和安全性，产品维护的周期也会比较长。</p>\n<h4 id=\"2-是否免费\"><a href=\"#2-是否免费\" class=\"headerlink\" title=\"2.是否免费\"></a>2.是否免费</h4><p>好的产品前期都会给用户充足的体验时间。如果使用一段时间我发现这款软件确实好用而且费用又付的起，他能给我带来的收益绝不止软件价钱本身，我会选择付费。（太贵当我没说，白嫖乞丐版🤐）</p>\n<h4 id=\"3-是否开源\"><a href=\"#3-是否开源\" class=\"headerlink\" title=\"3.是否开源\"></a>3.是否开源</h4><p>开源≠免费，虽然很多开源软件是免费的。开源软件一般都是大神（们）用爱发电的结晶，代码透明相对安全，多人协作让功能更新和版本迭代也变得比较快，如果体验做的不错很容易成为爆款。</p>\n<h4 id=\"4-是否易用\"><a href=\"#4-是否易用\" class=\"headerlink\" title=\"4.是否易用\"></a>4.是否易用</h4><p>易用也是比较关键的。一般我会考虑的几点因素：</p>\n<ol>\n<li>访问速度快慢：有些软件从功能开发，界面设计，到用户体验都很不错，做的很好无奈可能是由于还没开拓国内市场（慢到无法访问），导致综合体验大打折扣，所以并不是很推荐</li>\n<li>操作简单方便：上手容易，功能明确，操作简单，界面美观，软件稳定即可（其实很难）</li>\n<li>是否支持中文：最喜欢Simplified Chinese，第二选择是English。不过大多数软件都是开发的英文版本，后期做的国际化处理👩‍🎓</li>\n</ol>\n<p>综合以上4个方面的考量，当我需要找一款工具软件时，就有了比较合理的选择方向。下面是我常用的一些工具：</p>\n<p>📌 在线作图    |    <a href=\"https://www.processon.com/\" target=\"_blank\" rel=\"noopener\">processon</a>    |    <a href=\"https://excalidraw.com/\" target=\"_blank\" rel=\"noopener\">excalidraw</a>    |    <a href=\"https://app.diagrams.net/\" target=\"_blank\" rel=\"noopener\">diagrams</a>    |    <a href=\"http://asciiflow.com/\" target=\"_blank\" rel=\"noopener\">ASCIIFlow</a>    |</p>\n<p>📌 代码编辑器    |    <a href=\"https://www.sublimetext.com/\" target=\"_blank\" rel=\"noopener\">Sublime Text</a>    |    <a href=\"https://code.visualstudio.com/\" target=\"_blank\" rel=\"noopener\">VS Code</a>    |</p>\n<p>📌 笔记/TODO    |    <a href=\"https://joplinapp.org/\" target=\"_blank\" rel=\"noopener\">Joplin</a>    |    <a href=\"https://www.notion.so/\" target=\"_blank\" rel=\"noopener\">Notion</a>    |    <a href=\"https://www.yinxiang.com/\" target=\"_blank\" rel=\"noopener\">印象笔记</a>    |</p>\n<p>📌 文件同步    |    <a href=\"https://www.jianguoyun.com/\" target=\"_blank\" rel=\"noopener\">坚果云</a>    |</p>\n<p>📌 MySQL GUI    |    <a href=\"https://github.com/webyog/sqlyog-community/blob/master/README.md\" target=\"_blank\" rel=\"noopener\">SQLyog Community Edition</a>    |</p>\n<p>📌 文件比较    |    <a href=\"https://truehumandesign.se/s_diffinity.php\" target=\"_blank\" rel=\"noopener\">Diffinity</a>    |    <a href=\"https://www.diffchecker.com/\" target=\"_blank\" rel=\"noopener\">diffchecker</a>    |    <a href=\"https://meldmerge.org/\" target=\"_blank\" rel=\"noopener\">Meld</a>    |</p>\n<p>📌 代码转换    |    <a href=\"http://www.jsonschema2pojo.org/\" target=\"_blank\" rel=\"noopener\">jsonschema2pojo</a>    |    <a href=\"https://www.json.cn/\" target=\"_blank\" rel=\"noopener\">json.cn</a>    |    <a href=\"https://www.jsonformatter.io/\" target=\"_blank\" rel=\"noopener\">JSONFormatter</a>    |    <a href=\"https://www.urlencoder.io/\" target=\"_blank\" rel=\"noopener\">URLEncoder</a>    |    <a href=\"https://www.base64encoder.io/\" target=\"_blank\" rel=\"noopener\">Base64Encoder</a>    |</p>\n<p>📌 变量命名    |    <a href=\"http://p8z.fun/\" target=\"_blank\" rel=\"noopener\">P8Z</a>    |    <a href=\"https://unbug.github.io/codelf/\" target=\"_blank\" rel=\"noopener\">codelf</a>    |</p>\n<p>📌 GitHub下载    |    <a href=\"http://g.widyun.com/\" target=\"_blank\" rel=\"noopener\">http://g.widyun.com/</a>    |    <a href=\"https://gitzip.org/\" target=\"_blank\" rel=\"noopener\">GitZip for github</a>    |    <a href=\"https://kinolien.github.io/gitzip/\" target=\"_blank\" rel=\"noopener\">GitZip</a>    |</p>\n<p>📌 截图贴图    |    <a href=\"https://zh.snipaste.com/\" target=\"_blank\" rel=\"noopener\">snipaste</a>    |    </p>\n<p>持续更新</p>\n","site":{"data":{}},"excerpt":"","more":"<p>工作中常用的一些工具，以Windows上软件，Chrome插件和网页为主，整理记录方便自己查找。个人而言从发现一款软件，到最后能长期使用，大致经历的过程是这样的：</p>\n<h4 id=\"1-是否主流\"><a href=\"#1-是否主流\" class=\"headerlink\" title=\"1.是否主流\"></a>1.是否主流</h4><p>相信大家的选择。一般来说用户基数大的软件，都有不错的体验和安全性，产品维护的周期也会比较长。</p>\n<h4 id=\"2-是否免费\"><a href=\"#2-是否免费\" class=\"headerlink\" title=\"2.是否免费\"></a>2.是否免费</h4><p>好的产品前期都会给用户充足的体验时间。如果使用一段时间我发现这款软件确实好用而且费用又付的起，他能给我带来的收益绝不止软件价钱本身，我会选择付费。（太贵当我没说，白嫖乞丐版🤐）</p>\n<h4 id=\"3-是否开源\"><a href=\"#3-是否开源\" class=\"headerlink\" title=\"3.是否开源\"></a>3.是否开源</h4><p>开源≠免费，虽然很多开源软件是免费的。开源软件一般都是大神（们）用爱发电的结晶，代码透明相对安全，多人协作让功能更新和版本迭代也变得比较快，如果体验做的不错很容易成为爆款。</p>\n<h4 id=\"4-是否易用\"><a href=\"#4-是否易用\" class=\"headerlink\" title=\"4.是否易用\"></a>4.是否易用</h4><p>易用也是比较关键的。一般我会考虑的几点因素：</p>\n<ol>\n<li>访问速度快慢：有些软件从功能开发，界面设计，到用户体验都很不错，做的很好无奈可能是由于还没开拓国内市场（慢到无法访问），导致综合体验大打折扣，所以并不是很推荐</li>\n<li>操作简单方便：上手容易，功能明确，操作简单，界面美观，软件稳定即可（其实很难）</li>\n<li>是否支持中文：最喜欢Simplified Chinese，第二选择是English。不过大多数软件都是开发的英文版本，后期做的国际化处理👩‍🎓</li>\n</ol>\n<p>综合以上4个方面的考量，当我需要找一款工具软件时，就有了比较合理的选择方向。下面是我常用的一些工具：</p>\n<p>📌 在线作图    |    <a href=\"https://www.processon.com/\" target=\"_blank\" rel=\"noopener\">processon</a>    |    <a href=\"https://excalidraw.com/\" target=\"_blank\" rel=\"noopener\">excalidraw</a>    |    <a href=\"https://app.diagrams.net/\" target=\"_blank\" rel=\"noopener\">diagrams</a>    |    <a href=\"http://asciiflow.com/\" target=\"_blank\" rel=\"noopener\">ASCIIFlow</a>    |</p>\n<p>📌 代码编辑器    |    <a href=\"https://www.sublimetext.com/\" target=\"_blank\" rel=\"noopener\">Sublime Text</a>    |    <a href=\"https://code.visualstudio.com/\" target=\"_blank\" rel=\"noopener\">VS Code</a>    |</p>\n<p>📌 笔记/TODO    |    <a href=\"https://joplinapp.org/\" target=\"_blank\" rel=\"noopener\">Joplin</a>    |    <a href=\"https://www.notion.so/\" target=\"_blank\" rel=\"noopener\">Notion</a>    |    <a href=\"https://www.yinxiang.com/\" target=\"_blank\" rel=\"noopener\">印象笔记</a>    |</p>\n<p>📌 文件同步    |    <a href=\"https://www.jianguoyun.com/\" target=\"_blank\" rel=\"noopener\">坚果云</a>    |</p>\n<p>📌 MySQL GUI    |    <a href=\"https://github.com/webyog/sqlyog-community/blob/master/README.md\" target=\"_blank\" rel=\"noopener\">SQLyog Community Edition</a>    |</p>\n<p>📌 文件比较    |    <a href=\"https://truehumandesign.se/s_diffinity.php\" target=\"_blank\" rel=\"noopener\">Diffinity</a>    |    <a href=\"https://www.diffchecker.com/\" target=\"_blank\" rel=\"noopener\">diffchecker</a>    |    <a href=\"https://meldmerge.org/\" target=\"_blank\" rel=\"noopener\">Meld</a>    |</p>\n<p>📌 代码转换    |    <a href=\"http://www.jsonschema2pojo.org/\" target=\"_blank\" rel=\"noopener\">jsonschema2pojo</a>    |    <a href=\"https://www.json.cn/\" target=\"_blank\" rel=\"noopener\">json.cn</a>    |    <a href=\"https://www.jsonformatter.io/\" target=\"_blank\" rel=\"noopener\">JSONFormatter</a>    |    <a href=\"https://www.urlencoder.io/\" target=\"_blank\" rel=\"noopener\">URLEncoder</a>    |    <a href=\"https://www.base64encoder.io/\" target=\"_blank\" rel=\"noopener\">Base64Encoder</a>    |</p>\n<p>📌 变量命名    |    <a href=\"http://p8z.fun/\" target=\"_blank\" rel=\"noopener\">P8Z</a>    |    <a href=\"https://unbug.github.io/codelf/\" target=\"_blank\" rel=\"noopener\">codelf</a>    |</p>\n<p>📌 GitHub下载    |    <a href=\"http://g.widyun.com/\" target=\"_blank\" rel=\"noopener\">http://g.widyun.com/</a>    |    <a href=\"https://gitzip.org/\" target=\"_blank\" rel=\"noopener\">GitZip for github</a>    |    <a href=\"https://kinolien.github.io/gitzip/\" target=\"_blank\" rel=\"noopener\">GitZip</a>    |</p>\n<p>📌 截图贴图    |    <a href=\"https://zh.snipaste.com/\" target=\"_blank\" rel=\"noopener\">snipaste</a>    |    </p>\n<p>持续更新</p>\n"}],"PostAsset":[{"_id":"source/_posts/决策树构造原理/PlayTennis.png","slug":"PlayTennis.png","post":"ckc9dk3cs000mnsvn9sup35ww","modified":0,"renderable":0},{"_id":"source/_posts/决策树构造原理/img02.png","slug":"img02.png","post":"ckc9dk3cs000mnsvn9sup35ww","modified":0,"renderable":0},{"_id":"source/_posts/决策树构造原理/img03.png","slug":"img03.png","post":"ckc9dk3cs000mnsvn9sup35ww","modified":0,"renderable":0},{"_id":"source/_posts/决策树构造原理/img04.png","slug":"img04.png","post":"ckc9dk3cs000mnsvn9sup35ww","modified":0,"renderable":0},{"_id":"source/_posts/决策树构造原理/tree.png","slug":"tree.png","post":"ckc9dk3cs000mnsvn9sup35ww","modified":0,"renderable":0}],"PostCategory":[{"post_id":"ckc9dk3bj0002nsvna6hog06h","category_id":"ckc9dk3bt0004nsvnf5hyhahy","_id":"ckc9dk3cd000ensvnb99h3hk0"},{"post_id":"ckc9dk3bp0003nsvnbf5ih6jf","category_id":"ckc9dk3c60009nsvn17z1ce8i","_id":"ckc9dk3cr000knsvnhg3dar4l"},{"post_id":"ckc9dk3by0006nsvn6djh52ho","category_id":"ckc9dk3bt0004nsvnf5hyhahy","_id":"ckc9dk3cz000pnsvnd9rm1cjs"},{"post_id":"ckc9dk3cl000insvn2pr1hp8a","category_id":"ckc9dk3bt0004nsvnf5hyhahy","_id":"ckc9dk3d2000tnsvn1rlh7xjt"},{"post_id":"ckc9dk3c10007nsvn85q19wa0","category_id":"ckc9dk3cq000jnsvnc679gbba","_id":"ckc9dk3d2000unsvn6b3x61qy"},{"post_id":"ckc9dk3c8000cnsvnbi6zec6n","category_id":"ckc9dk3cz000rnsvna514bvnb","_id":"ckc9dk3d5000xnsvn4ki674cg"},{"post_id":"ckc9dk3cb000dnsvn5dql7skh","category_id":"ckc9dk3d2000vnsvnau60a854","_id":"ckc9dk3d80012nsvnegl20vq3"},{"post_id":"ckc9dk3cs000mnsvn9sup35ww","category_id":"ckc9dk3cz000rnsvna514bvnb","_id":"ckc9dk3da0016nsvne59j8a2d"},{"post_id":"ckc9dk3cv000onsvn3b3761ql","category_id":"ckc9dk3d70011nsvnc132e32v","_id":"ckc9dk3dc001ansvnffl429ih"}],"PostTag":[{"post_id":"ckc9dk3bj0002nsvna6hog06h","tag_id":"ckc9dk3bx0005nsvn6af1dcx4","_id":"ckc9dk3c8000bnsvn010o5mbv"},{"post_id":"ckc9dk3bp0003nsvnbf5ih6jf","tag_id":"ckc9dk3c6000ansvn3idp4u2d","_id":"ckc9dk3cv000nnsvnbnzq1ew8"},{"post_id":"ckc9dk3bp0003nsvnbf5ih6jf","tag_id":"ckc9dk3ce000gnsvn61s2eia6","_id":"ckc9dk3cz000qnsvnbbez34qh"},{"post_id":"ckc9dk3by0006nsvn6djh52ho","tag_id":"ckc9dk3cr000lnsvn72oy9fde","_id":"ckc9dk3d70010nsvn2p5f1to5"},{"post_id":"ckc9dk3by0006nsvn6djh52ho","tag_id":"ckc9dk3d0000snsvnehbwgvlo","_id":"ckc9dk3d80013nsvnbx8ocf19"},{"post_id":"ckc9dk3by0006nsvn6djh52ho","tag_id":"ckc9dk3d3000wnsvndpur2cg5","_id":"ckc9dk3d90015nsvnd3dp8f9j"},{"post_id":"ckc9dk3c10007nsvn85q19wa0","tag_id":"ckc9dk3d6000znsvne2pw5di2","_id":"ckc9dk3da0017nsvn639jgxaj"},{"post_id":"ckc9dk3c40008nsvn87av8umz","tag_id":"ckc9dk3c6000ansvn3idp4u2d","_id":"ckc9dk3db0019nsvnbg17803e"},{"post_id":"ckc9dk3c8000cnsvnbi6zec6n","tag_id":"ckc9dk3da0018nsvnhhst7rv0","_id":"ckc9dk3dd001cnsvn1ntm8lvh"},{"post_id":"ckc9dk3cb000dnsvn5dql7skh","tag_id":"ckc9dk3dc001bnsvnfwe1dapv","_id":"ckc9dk3dl001fnsvnbj79ct1v"},{"post_id":"ckc9dk3cb000dnsvn5dql7skh","tag_id":"ckc9dk3dd001dnsvnfcrice54","_id":"ckc9dk3dl001gnsvn3uto0pvx"},{"post_id":"ckc9dk3cl000insvn2pr1hp8a","tag_id":"ckc9dk3cr000lnsvn72oy9fde","_id":"ckc9dk3dn001jnsvnefca7zzv"},{"post_id":"ckc9dk3cl000insvn2pr1hp8a","tag_id":"ckc9dk3dl001hnsvndp62fdey","_id":"ckc9dk3dn001knsvnahxrftwq"},{"post_id":"ckc9dk3cs000mnsvn9sup35ww","tag_id":"ckc9dk3dm001insvn5z5691cg","_id":"ckc9dk3do001mnsvn7q6kctns"},{"post_id":"ckc9dk3cv000onsvn3b3761ql","tag_id":"ckc9dk3dn001lnsvndnw521ka","_id":"ckc9dk3do001nnsvnen3x7ydm"}],"Tag":[{"name":"HashMap","_id":"ckc9dk3bx0005nsvn6af1dcx4"},{"name":"Hexo","_id":"ckc9dk3c6000ansvn3idp4u2d"},{"name":"Travis CI","_id":"ckc9dk3ce000gnsvn61s2eia6"},{"name":"Java","_id":"ckc9dk3cr000lnsvn72oy9fde"},{"name":"锁","_id":"ckc9dk3d0000snsvnehbwgvlo"},{"name":"多线程","_id":"ckc9dk3d3000wnsvndpur2cg5"},{"name":"Hive","_id":"ckc9dk3d6000znsvne2pw5di2"},{"name":"PLDA","_id":"ckc9dk3da0018nsvnhhst7rv0"},{"name":"信息","_id":"ckc9dk3dc001bnsvnfwe1dapv"},{"name":"熵","_id":"ckc9dk3dd001dnsvnfcrice54"},{"name":"开发规范","_id":"ckc9dk3dl001hnsvndp62fdey"},{"name":"决策树","_id":"ckc9dk3dm001insvn5z5691cg"},{"name":"开发","_id":"ckc9dk3dn001lnsvndnw521ka"}]}}